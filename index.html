<!--
- [ ] type scale
- [ ] refactor
 -->
<!doctype html>
<html lang=en>
<meta charset=utf-8>
<meta content="width=device-width,initial-scale=1" name=viewport>
<title>Huey—HSL Color Toy</title>
<style>
    /* layout debugger */
    * {
        /* outline: .5px dotted black; */
    }

    :root {
        --hue: ;
        --saturation: ;
        --lightness: ;
        --color-canvas: hsl(var(--hue), calc(var(--saturation) * 1%), calc(var(--lightness) * 1%));
        --color-light: hsl(var(--hue), 80%, 95%);
        --color-dark: hsl(var(--hue), 80%, 25%);
        --color-action-default: hsl(var(--hue), 80%, 98%);
        --color-action-hover: hsl(var(--hue), 40%, 87%);
        --color-action-active: hsl(var(--hue), 35%, 80%);
        --color-code: hsl(var(--hue), 20%, 85%);
        --color-shadow: var(--hue) 3% 10%;

        --typography-typeface-monospace: ui-monospace, monospace;
        --typography-typeface-sans-serif: system-ui, sans-serif;
        --typography-size-13-16: clamp(0.8125rem, 0.7589rem + 0.2679vw, 1rem);
        --typography-size-15-20: clamp(0.9141rem, 0.8181rem + 0.4799vw, 1.25rem);
        --typography-size-16-25: clamp(1.0283rem, 0.8757rem + 0.7631vw, 1.5625rem);
        --typography-size-19-31: clamp(1.1569rem, 0.9294rem + 1.1375vw, 1.9531rem);
        --typography-size-34-48: clamp(2.125rem, 1.875rem + 1.25vw, 3rem);
        --typography-size-27-61: clamp(1.6472rem, 1.0279rem + 3.0965vw, 3.8147rem);
        --typography-leading-open: 1.5;
        --typography-leading-tight: 1;
        --typography-tracking-caps: 0.01cap;
        --typography-tracking-mono: -0.4ch;

        --spacing-2xs: clamp(0.1875rem, 0.0982rem + 0.4464vw, 0.5rem);
        --spacing-xs: clamp(0.4375rem, 0.4196rem + 0.0893vw, 0.5rem);
        --spacing-s: clamp(0.4375rem, 0.3482rem + 0.4464vw, 0.75rem);
        --spacing-m: clamp(0.4375rem, 0.2768rem + 0.8036vw, 1rem);
        --spacing-l: clamp(1.25rem, 1.1786rem + 0.3571vw, 1.5rem);
        --spacing-xl: clamp(1.625rem, 1.5179rem + 0.5357vw, 2rem);
        --spacing-2xl: clamp(1.625rem, 1.2321rem + 1.9643vw, 3rem);
        --spacing-l-xl: clamp(1.25rem, 1.0357rem + 1.0714vw, 2rem);
        --spacing-xl-2xl: clamp(2rem, 1.7143rem + 1.4286vw, 3rem);

        --circle: 50%;
        --corner: .6rem;
        --diameter: 35vmin;
        --shadow-strength: 1%;
        --shadow:
            0 -2px 5px 0 hsl(var(--color-shadow) / calc(var(--shadow-strength) + 2%)),
            0 1px 1px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 3%)),
            0 2px 2px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 3%)),
            0 5px 5px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 4%)),
            0 9px 9px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 5%)),
            0 16px 16px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 6%));
        --top: 999;
        --ease-io-circular: cubic-bezier(0.785, 0.135, 0.15, 0.86);
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    html {
        min-block-size: 100vh;
        min-block-size: 100dvh;
        -moz-text-size-adjust: none;
        -webkit-text-size-adjust: none;
        text-size-adjust: none;
    }

    body {
        background-color: var(--color-canvas);
        font-family: var(--typography-typeface-sans-serif);
        font-size: var(--typography-size-15-20);
        line-height: var(--typography-leading-open);
        min-block-size: 100vh;
        min-block-size: 100dvh;
        transition: background-color 120ms;
    }

    h1 {
        background-color: var(--color-dark);
        border-radius: 0 0 var(--corner) var(--corner);
        color: var(--color-action-default);
        cursor: pointer;
        font-family: var(--typography-typeface-monospace);
        font-size: var(--typography-size-34-48);
        line-height: var(--typography-leading-tight);
        padding-block: .5rem .8rem;
        padding-inline: var(--spacing-l);
        transition-duration: 120ms;
        transition-property: transform, color;
        transition-timing-function: ease-in-out;
        user-select: none;
    }

    :where(h1:hover, h1.mode-transitioning) {
        color: var(--color-action-hover);
        transform: scale(1.05);
    }

    h1:active,
    h1:focus-visible {
        color: var(--color-action-default);
        transform: scale(1.1);
    }

    h2 {
        font-size: var(--typography-size-19-31);
        letter-spacing: var(--typography-tracking-caps);
        line-height: var(--typography-leading-tight);
        text-transform: uppercase;
    }

    h3 {
        font-size: var(--typography-size-16-25);
    }

    p {
        font-size: var(--typography-size-15-20);
        -webkit-hyphens: auto;
        -webkit-hyphenate-limit-before: 3;
        -webkit-hyphenate-limit-after: 3;
        -webkit-hyphenate-limit-chars: 6 3 3;
        -webkit-hyphenate-limit-lines: 2;
        -webkit-hyphenate-limit-last: always;
        -webkit-hyphenate-limit-zone: 8%;
        hyphens: auto;
        hyphenate-limit-chars: 6 3 3;
        hyphenate-limit-lines: 2;
        hyphenate-limit-last: always;
        hyphenate-limit-zone: 8%;
    }

    ul {
        list-style-type: none;
    }

    footer small {
        background-color: var(--color-dark);
        color: var(--color-light);
        display: inline-block;
        font-size: var(--typography-size-13-16);
        padding-block: var(--spacing-2xs);
        padding-inline: var(--spacing-m)
    }

    button {
        align-items: center;
        background-color: var(--color-action-default);
        border: 3px solid var(--color-dark);
        border-radius: var(--circle);
        box-shadow: var(--shadow);
        color: var(--color-dark);
        cursor: pointer;
        display: inline-flex;
        font: inherit;
        padding: var(--spacing-xs);
        margin: var(--spacing-s);
        touch-action: manipulation;
        transition-property: background-color, outline;
        transition-duration: 120ms;
        transition-timing-function: ease-in-out
    }

    button:hover {
        background-color: var(--color-action-hover)
    }

    :where(button:active, button:focus-visible) {
        outline: 5px solid hsla(var(--hue) 80% 25% / .5);
        outline-offset: -1px
    }

    button:active {
        background-color: var(--color-action-active)
    }

    main {
        position: relative;
        height: var(--diameter);
        width: var(--diameter)
    }

    fieldset {
        --cell-size: fit-content;
        --offset: calc(360deg / var(--i-count));
        position: absolute;
        top: 0;
        left: 0;
        display: grid;
        grid: var(--cell-size)/var(--cell-size);
        place-content: center;
        height: 100%;
        width: 100%;
        border: none;
        padding: 0;
    }

    fieldset>* {
        grid-area: 1/1
    }

    input {
        --angle: calc((var(--i) * var(--offset)) - 90deg);
        appearance: none;
        border-radius: var(--circle);
        cursor: pointer;
        height: 2.75rem;
        width: 2.75rem;
        touch-action: manipulation;
        transform: translate3d(calc(cos(var(--angle)) * var(--diameter)), calc(sin(var(--angle)) * var(--diameter)), 0);
        will-change: transform;
        transition: transform 480ms var(--ease-io-circular), background-color 480ms ease-out;
    }

    :where(input:checked, input:focus-visible) {
        outline: 3px solid var(--color-light);
        z-index: var(--top);
        transition: transform 480ms var(--ease-io-circular), background-color 480ms ease-out, outline 0.1s ease-out;
    }

    input:focus {
        z-index: var(--top)
    }

    .transition-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 2.75rem;
        height: 2.75rem;
        border-radius: var(--circle);
        background: transparent;
        border: none;
        box-shadow: 0 0 0 3px hsla(var(--hue), 80%, 95%, 0.7);
        z-index: var(--top);
        pointer-events: none;
        transform-origin: center;
        opacity: 1;
    }

    @keyframes rotateIndicator {
        from {
            transform: translate(-50%, -50%) rotate(var(--start-angle)) translateX(var(--diameter));
        }

        to {
            transform: translate(-50%, -50%) rotate(var(--end-angle)) translateX(var(--diameter));
        }
    }

    .transition-indicator.animate {
        animation: rotateIndicator 480ms var(--ease-io-circular) forwards;
        animation-fill-mode: forwards;
    }

    .transition-indicator.fade-out {
        opacity: 0;
        transition: opacity 0.2s ease-out;
    }

    fieldset.mode-transitioning {
        pointer-events: none;
    }

    fieldset.mode-transitioning input {
        transition: transform 480ms var(--ease-io-circular), background-color 480ms ease-out;
    }

    .mode-hue input,
    .mode-saturation input,
    .mode-lightness input {
        transition: background-color 480ms ease-out;
    }

    .mode-hue input {
        background-color: hsl(calc(var(--i) * 1deg), 100%, 50%);
    }

    .mode-saturation input {
        background-color: hsl(var(--hue), calc(var(--i) * 1%), 50%);
    }

    .mode-lightness input {
        background-color: hsl(var(--hue), calc(var(--saturation) * 1%), calc(var(--i) * 1%));
    }

    .value-display {
        position: absolute;
        top: 50%;
        left: 50%;
        height: 100%;
        width: 100%;
        overflow: visible;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: var(--top);
    }

    text {
        fill: var(--color-light);
        font-family: var(--typography-typeface-monospace);
        font-weight: 700;
        dominant-baseline: central;
        text-anchor: middle;
        paint-order: stroke;
        stroke: var(--color-dark);
        stroke-width: 2px;
        stroke-linejoin: round;
    }

    dialog {
        background-color: var(--color-light);
        border-width: 3px;
        border-radius: var(--corner);
        box-shadow: var(--shadow);
        color: var(--color-dark);
        margin-block: auto !important;
        max-inline-size: 58rem !important;
        padding-block: var(--spacing-xl-2xl);
        padding-inline: var(--spacing-l-xl);
        z-index: var(--top);
    }

    dialog * {
        text-align: left;
    }

    :where(dialog)::backdrop {
        background: hsla(0, 0%, 0%, 0.35);
    }

    :where(dialog),
    :where(dialog)::backdrop {
        opacity: 0;
        transition-behavior: allow-discrete;
        transition-duration: 360ms;
        transition-property: opacity, overlay;
        transition-timing-function: ease-in-out;
    }

    :where(dialog[open]),
    :where(dialog[open])::backdrop {
        opacity: 1;
    }

    @starting-style {

        :where(dialog[open]),
        :where(dialog[open])::backdrop {
            opacity: 0;
        }
    }

    a {
        color: currentColor;
        text-decoration-color: currentColor;
        text-underline-offset: 0.25ex;
        text-decoration-thickness: 0.1ex
    }

    a:hover {
        text-decoration-thickness: 0.15ex
    }

    :where(abbr[title]) {
        cursor: help;
        font-variant-caps: all-small-caps;
        text-decoration-line: underline;
        text-decoration-style: dotted
    }

    :where(i, var) {
        font-variant-caps: all-small-caps;
        font-style: normal;
    }

    code {
        background-color: var(--color-code);
        color: var(--color-dark);
        border-radius: var(--corner);
        padding-block: .1em;
        padding-inline: .2em;
        text-wrap: nowrap;
    }

    footer a {
        padding-inline: var(--spacing-m);
        text-decoration: none;
    }

    footer small:nth-of-type(3) a {
        padding-inline: 0;
        text-decoration: underline;
    }

    footer small:first-of-type {
        border-top-right-radius: var(--corner);
    }

    footer small:last-of-type {
        border-top-left-radius: var(--corner);
    }

    footer small:nth-of-type(2) {
        border-top-right-radius: var(--corner);
        border-top-left-radius: var(--corner);
        font-weight: 700;
        padding-inline: 0;
        transition-duration: 120ms;
        transition-property: transform, color;
        transition-timing-function: ease-in-out;
    }

    footer small:nth-of-type(2):hover {
        color: var(--color-action-hover);
        transform: scale(1.05);
    }

    footer small:nth-of-type(2):active,
    footer small:nth-of-type(2):focus-visible {
        color: var(--color-action-default);
        transform: scale(1.1);
    }

    .center {
        box-sizing: content-box;
        margin-inline: auto;
        max-inline-size: none;
        text-align: center
    }

    .cover {
        display: flex;
        flex-direction: column;
        min-block-size: 100vh
    }

    .cover>* {
        margin-block: 0
    }

    .cover>:first-child:not(main) {
        margin-block-start: 0
    }

    .cover>:last-child:not(main) {
        margin-block-end: 0
    }

    .cover>main {
        margin-block: auto
    }

    .with-icon {
        display: inline-flex;
        align-items: center
    }

    .icon {
        height: 2.6cap;
        width: 2.6cap;
        transition: opacity 300ms ease-in-out 240ms;
    }

    dialog .icon {
        height: 1.6cap;
        width: 1.6cap;
    }

    .with-icon .icon {
        margin-inline-end: 0
    }

    .icon-check {
        opacity: 0;
        position: absolute
    }

    .copy-success .icon-copy {
        opacity: 0
    }

    .copy-success .icon-check {
        opacity: 1
    }

    .stack-x {
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-m);
        align-items: flex-start;
        justify-content: space-between
    }

    [class^='stack-y'] {
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }

    [class^='stack-y']>* {
        margin-block: 0;
    }

    .stack-y-2xs>*+* {
        margin-block-start: var(--spacing-2xs);
    }

    .stack-y-xs>*+* {
        margin-block-start: var(--spacing-xs);
    }

    .stack-y-s>*+* {
        margin-block-start: var(--spacing-s)
    }

    .stack-y-m>*+* {
        margin-block-start: var(--spacing-m);
    }

    .stack-y-l>*+* {
        margin-block-start: var(--spacing-l);
    }

    .stack-y-xl>*+* {
        margin-block-start: var(--spacing-xl);
    }

    .stack-y-2xl>*+* {
        margin-block-start: var(--spacing-2xl);
    }

    .aic {
        align-items: center;
    }

    .m0 {
        margin: 0;
    }

    .mbs2xs {
        margin-block-start: var(--spacing-2xs);
    }

    .ttm {
        letter-spacing: var(--typography-tracking-mono);
    }

    .vh:not(:focus):not(:active):not(:focus-within) {
        clip-path: inset(50%);
        block-size: 1px;
        inline-size: 1px;
        overflow: hidden;
        position: absolute !important;
        white-space: nowrap
    }

    @media (prefers-reduced-motion: reduce) {

        *,
        *::before,
        *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
</style>
<meta content=yes name=mobile-web-app-capable>
<meta content=black name=apple-mobile-web-app-status-bar-style>
<meta content="Timothy Martens" name=author>
<meta content="Huey—HSL Color Toy" name=description>

<body class="center cover">

    <header class=stack-x>
        <button class=with-icon id=random-btn title="Random Color"><svg aria-hidden=true class=icon>
                <use href=#icon-random></use>
            </svg> <span class=vh>Randomize</span>
        </button>
        <h1 class=mode-title title="Switch Modes">H</h1>
        <button class=with-icon id=copy-btn title="Copy Color"><svg aria-hidden=true class="icon icon-copy">
                <use href=#icon-copy></use>
            </svg> <svg aria-hidden=true class="icon icon-check">
                <use href=#icon-check></use>
            </svg> <span class=vh>Copy/Confirm Copy</span>
        </button>
    </header>

    <main class=center>
        <fieldset aria-describedby=color-instructions aria-label="Color component selector" aria-labelledby=mode-title role=radiogroup style=--i-count:360></fieldset>
        <svg aria-hidden="true" class="value-display" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" font-size="61"><text class="component-value" x="50" y="50">360</text></svg>
    </main>

    <footer class=stack-x>
        <small><i>HUE</i>y—<abbr title="Hue, Saturation, Lightness">HSL</abbr> color toy</small>
        <small><a title="About this app" href="#" id="info">?</a></small>
        <small>© '25 <a title="Visit Timothy Martens' website" href=https://timagineer.com>Timagineer</a></small>
    </footer>

    <dialog id="dialog" role="dialog" class="center stack-y-l is a web toy that teaches HSL color through visual interaction. HSL stands for Hue, Saturation, Light">

        <header class="stack-x aic">
            <h2>About</h2>
            <button class="with-icon m0" id=close title="Close Modal">
                <svg aria-hidden=true class=icon>
                    <use href=#icon-close></use>
                </svg><span class=vh>Close</span>
            </button>
        </header>

        <section class="stack-y-m" id="color-instructions">

            <p><i>HUE</i>y is a web toy that teaches <a href="https://en.wikipedia.org/wiki/HSL_and_HSV"><abbr title="Hue, Saturation, Lightness">HSL</abbr> color</a> through visual interaction. <abbr title="Hue, Saturation, Lightness">HSL</abbr> stands for <strong>Hue</strong>, <strong>Saturation</strong>, <strong>Lightness</strong>. In <abbr title="Cascading Style Sheets">CSS</abbr>, you write <abbr title="Hue, Saturation, Lightness">HSL</abbr> colors as <code>hsl(H S L<span class="ttm">)</span></code>. <i>HUE</i>y&apos;s color is <code id="hueyColor">hsl(deg &percnt; &percnt;<span class="ttm">)</span></code>.</p>

            <h3>Understanding HSL</h3>

            <p class="mbs2xs">
                <strong>Hue</strong> refers to a color&apos;s name, e.g., red, yellow, blue. Hue is a spectral wavelength, expressed as an angle and measured in degrees from 0° to 360°.<br>
                <strong>Saturation</strong> governs a color&apos;s intensity, measured as a percentage from 0% to 100%. At 0% saturation, colors becomes pure gray. 100% saturation is the most vibrant version of a color.<br>
                <strong>Lightness</strong>, also measured from 0% to 100%, determines how bright or dark a color is. 0% lightness is black. 100% lightness is white.
            </p>

            <h3>How to operate HUEy</h3>
            <ul class="mbs2xs">
                <li><strong>Switch modes</strong>: click the H/S/L header, press tab or &apos;h&apos;, &apos;s&apos;, &apos;l&apos;</li>
                <li><strong>Adjust values</strong>: click, click and drag, or use arrow keys (&apos;&uarr;&apos;, &apos;&darr;&apos;, &apos;&larr;&apos;, &apos;&rarr;&apos;)</li>
                <li><strong>Accelerate</strong>: hold down arrow keys for quicker changes</li>
                <li><strong>Get inspired</strong>: press &apos;r&apos; or click the Random Color button</li>
                <li><strong>Copy color</strong>: press &apos;c&apos; or click the Copy Color button</li>
            </ul>

            <p>Share your <i>HUE</i>y color discoveries on <a href="https://www.linkedin.com/in/timothyfmartens/" target="_blank">LinkedIn</a>!</p>

        </section>

    </dialog>

    <svg aria-hidden=true class=vh xmlns=http://www.w3.org/2000/svg display=none height=0 width=0 xmlns:xlink=http://www.w3.org/1999/xlink>
        <defs>
            <symbol id=icon-random title="Random Color Icon" viewBox="0 0 256 256">
                <path d="M32 72h23.06a64 64 0 0 1 52.08 26.8l41.72 58.4a64 64 0 0 0 52.08 26.8H232M208 48l24 24-24 24" fill=none stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=24 />
                <path d="m208 160 24 24-24 24M152.77 93.86A64 64 0 0 1 200.94 72H232M32 184h23.06a64 64 0 0 0 48.17-21.86" fill=none stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=24 />
            </symbol>
            <symbol id=icon-copy title="Copy Color Icon" viewBox="0 0 256 256">
                <path d="M0 0h256v256H0z" fill=none />
                <path d="M40 76h140v140H40z" fill=none stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=24 />
                <path d="M76 40h140v140" fill=none stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=24 />
            </symbol>
            <symbol id=icon-check title="Confirm Copy Color Icon" viewBox="0 0 256 256">
                <path d="m40 144 56 56L224 72" fill=none stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=24 />
            </symbol>
            <symbol id=icon-close title="Close Icon" viewBox="0 0 256 256">
                <path fill="none" d="M0 0h256v256H0z" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="M200 56 56 200M200 200 56 56" />
            </symbol>
        </defs>
    </svg>

    <script>
        const elements = {
            showBtn: document.getElementById("info"),
            closeBtn: document.getElementById("close"),
            dialog: document.getElementById("dialog"),
        };
        // Dialog event listeners
        if (elements.showBtn && elements.dialog) {
            elements.showBtn.addEventListener("click", () => {
                elements.dialog.showModal();
            });
        }

        if (elements.closeBtn && elements.dialog) {
            elements.closeBtn.addEventListener("click", () => {
                elements.dialog.close();
            });
        }
        const MODES = Object.freeze(["hue", "saturation", "lightness"]);
        const MODE_RANGES = Object.freeze({
            hue: { min: 1, max: 360 },
            saturation: { min: 0, max: 100 },
            lightness: { min: 0, max: 100 }
        });
        const MODE_LABELS = Object.freeze({ hue: "H", saturation: "S", lightness: "L" });
        const KEY_HOLD_DELAY = 1200; // delay before acceleration starts

        // Generate initial random color and set CSS variables immediately
        const generateInitialRandomColor = () => {
            const hue = Math.floor(360 * Math.random()) + 1;
            const saturation = Math.floor(101 * Math.random());
            const lightness = Math.floor(101 * Math.random());

            // Set CSS variables immediately to prevent flash
            const root = document.documentElement;
            root.style.setProperty("--hue", hue);
            root.style.setProperty("--saturation", saturation);
            root.style.setProperty("--lightness", lightness);
            root.style.setProperty("--color-canvas", `hsl(${hue}, ${saturation}%, ${lightness}%)`);

            return { hue, saturation, lightness };
        };

        // Set initial color immediately when script loads
        const initialColor = generateInitialRandomColor();

        const utils = {
            debounce(fn, delay) {
                let timeoutId;
                return (...args) => {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => fn.apply(this, args), delay);
                };
            },

            hslToRgb(h, s, l) {
                s /= 100;
                l /= 100;
                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;
                let r = 0, g = 0, b = 0;

                const hueSegment = Math.floor(h / 60);
                switch (hueSegment) {
                    case 0: [r, g, b] = [c, x, 0]; break;
                    case 1: [r, g, b] = [x, c, 0]; break;
                    case 2: [r, g, b] = [0, c, x]; break;
                    case 3: [r, g, b] = [0, x, c]; break;
                    case 4: [r, g, b] = [x, 0, c]; break;
                    case 5: [r, g, b] = [c, 0, x]; break;
                }

                return {
                    r: Math.round(255 * (r + m)),
                    g: Math.round(255 * (g + m)),
                    b: Math.round(255 * (b + m))
                };
            },

            getRelativeLuminance(r, g, b) {
                const toLinear = c => {
                    c /= 255;
                    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                };
                return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
            },

            getContrastRatio(color1, color2) {
                const lum1 = this.getRelativeLuminance(color1.r, color1.g, color1.b);
                const lum2 = this.getRelativeLuminance(color2.r, color2.g, color2.b);
                const [lighter, darker] = [Math.max(lum1, lum2), Math.min(lum1, lum2)];
                return (lighter + 0.05) / (darker + 0.05);
            },

            angleToValue(angle, mode) {
                const { min, max } = MODE_RANGES[mode];
                if (mode === "hue") return Math.max(1, Math.round(angle)) || 360;

                const normalizedAngle = angle / 360;
                return Math.max(min, Math.min(max, Math.round(min + normalizedAngle * (max - min))));
            },

            clamp: (value, min, max) => Math.max(min, Math.min(max, value))
        };

        class ColorState {
            constructor(initialState = {}) {
                this.state = {
                    hue: 360,
                    saturation: 100,
                    lightness: 50,
                    mode: "hue",
                    ...initialState
                };
                this.observers = [];
            }

            subscribe(callback) {
                this.observers.push(callback);
                return () => this.observers = this.observers.filter(obs => obs !== callback);
            }

            setState(updates) {
                const prevState = { ...this.state };
                this.state = { ...this.state, ...updates };
                this.observers.forEach(callback => callback(this.state, prevState));
            }

            get(key) {
                return key ? this.state[key] : this.state;
            }
        }

        class DOMManager {
            constructor(toy) {
                this.toy = toy;
                this.elements = this.cacheElements();
                this.lastCheckedAngle = null;
                this.currentTransitionIndicator = null;
                this.isInitialized = false;
            }

            cacheElements() {
                return {
                    root: document.documentElement,
                    fieldset: document.querySelector("fieldset"),
                    appTitle: document.querySelector(".mode-title"),
                    componentValue: document.querySelector(".component-value"),
                    copyBtn: document.getElementById("copy-btn"),
                    randomBtn: document.getElementById("random-btn"),
                    main: document.querySelector("main")
                };
            }

            updateModeDisplay(mode) {
                const { appTitle } = this.elements;
                // Add a class to trigger the color transition
                appTitle.classList.add('mode-transitioning');
                // Update the content and classes
                appTitle.textContent = MODE_LABELS[mode];
                this.elements.fieldset.className = `center mode-${mode}`;
                this.elements.fieldset.setAttribute("aria-label", `${mode} selector`);
                // Remove the transition class after the animation completes
                setTimeout(() => {
                    appTitle.classList.remove('mode-transitioning');
                }, 120);
            }

            regenerateInputs() {
                const mode = this.toy.state.get("mode");
                const value = this.toy.state.get(mode);
                const hasFocus = this.elements.fieldset.contains(document.activeElement);

                this.cleanupTransitionIndicator();
                this.elements.fieldset.classList.add("mode-transitioning");

                this.elements.fieldset.innerHTML = "";
                this.generateInputs(mode);
                this.addInputListeners();

                const targetInput = this.elements.fieldset.querySelector(`input[value="${value}"]`);
                if (targetInput) {
                    targetInput.checked = true;
                    targetInput.dispatchEvent(new Event('change'));
                    targetInput.focus();
                }

                this.lastCheckedAngle = this.getAngleForValue(value, mode);

                setTimeout(() => {
                    this.elements.fieldset.classList.remove("mode-transitioning");
                }, 600);
            }

            regenerateInputsWithAnimation(oldAngle, newAngle) {
                const fieldset = this.elements.fieldset;
                const mode = this.toy.state.get("mode");
                const value = this.toy.state.get(mode);
                const hasFocus = fieldset.contains(document.activeElement);

                this.toy.currentCheckedInputRef = null;

                this.cleanupTransitionIndicator();
                fieldset.classList.add("mode-transitioning");

                const shouldAnimate = this.isInitialized &&
                    oldAngle !== null &&
                    newAngle !== null &&
                    Math.abs(oldAngle - newAngle) > 1;

                if (shouldAnimate) {
                    this.animateClockwiseTransition(oldAngle, newAngle);
                }

                // Stage 1: Clear old inputs and prepare for transition
                fieldset.innerHTML = "";

                // Stage 2: Generate new inputs with a slight delay to allow for smooth transition
                requestAnimationFrame(() => {
                    this.generateInputs(mode);
                    this.addInputListeners();

                    // Stage 3: Update checked status and focus
                    requestAnimationFrame(() => {
                        const targetInput = fieldset.querySelector(`input[value="${value}"]`);
                        if (targetInput) {
                            targetInput.checked = true;
                            if (hasFocus) {
                                // Ensure we're not in a transition before focusing
                                if (!fieldset.classList.contains("mode-transitioning")) {
                                    targetInput.focus();
                                } else {
                                    // Wait for transition to complete before focusing
                                    setTimeout(() => {
                                        if (fieldset.contains(document.activeElement)) {
                                            targetInput.focus();
                                        }
                                    }, 300);
                                }
                            }
                        }
                        // Update last checked angle after regeneration
                        this.lastCheckedAngle = this.getAngleForValue(value, mode);
                    });
                });

                // Stage 4: Remove transition class after animation completes
                setTimeout(() => {
                    fieldset.classList.remove("mode-transitioning");
                }, shouldAnimate ? 600 : 400); // 480ms animation + 120ms fade-out
            }

            cleanupTransitionIndicator() {
                if (this.currentTransitionIndicator) {
                    this.currentTransitionIndicator.remove();
                    this.currentTransitionIndicator = null;
                }
            }

            getAngleForValue(value, mode) {
                const { min, max } = MODE_RANGES[mode];
                if (mode === "hue") {
                    return (value - 90 + 360) % 360;
                }
                const count = max - min + 1;
                const offset = 360 / count;
                return ((value - min) * offset - 90 + 360) % 360;
            }

            animateClockwiseTransition(startAngle, endAngle) {
                this.cleanupTransitionIndicator();

                const indicator = document.createElement('div');
                indicator.className = 'transition-indicator';
                // Set will-change only when animation is about to start
                indicator.style.willChange = 'transform, opacity';

                const main = this.elements.main;
                main.appendChild(indicator);

                this.currentTransitionIndicator = indicator;

                // Normalize angles to 0-360 range
                const normalizedStart = (startAngle % 360 + 360) % 360;
                const normalizedEnd = (endAngle % 360 + 360) % 360;

                // Calculate the shortest path
                let diff = normalizedEnd - normalizedStart;
                if (Math.abs(diff) > 180) {
                    diff = diff > 0 ? diff - 360 : diff + 360;
                }

                // Set the final angle based on the shortest path
                const finalAngle = normalizedStart + diff;

                // Set the animation properties
                indicator.style.setProperty('--start-angle', `${normalizedStart}deg`);
                indicator.style.setProperty('--end-angle', `${finalAngle}deg`);

                // Add animation class
                indicator.classList.add('animate');

                // Handle animation end
                indicator.addEventListener('animationend', () => {
                    // Remove will-change after animation completes
                    indicator.style.willChange = 'auto';

                    if (indicator.parentNode) {
                        indicator.classList.add('fade-out');
                        indicator.addEventListener('transitionend', () => {
                            if (indicator.parentNode) {
                                indicator.remove();
                            }
                            if (this.currentTransitionIndicator === indicator) {
                                this.currentTransitionIndicator = null;
                            }
                        }, { once: true });
                    }
                }, { once: true });
            }

            generateInputs(mode, targetElement) {
                const { min, max } = MODE_RANGES[mode];
                const count = mode === "hue" ? 360 : 101;
                this.elements.fieldset.style.setProperty("--i-count", count.toString());

                const tempFragment = document.createDocumentFragment();
                for (let i = min; i <= max; i++) {
                    tempFragment.appendChild(this.createRadioInput(i, mode));
                }
                (targetElement || this.elements.fieldset).appendChild(tempFragment);
            }

            createRadioInput(value, mode) {
                const input = document.createElement("input");
                const ariaLabels = {
                    hue: `${value} degrees`,
                    saturation: `${value} percent saturation`,
                    lightness: `${value} percent lightness`
                };

                Object.assign(input, {
                    type: "radio",
                    name: mode.charAt(0),
                    value: value
                });

                input.style.setProperty("--i", value);
                input.setAttribute("aria-label", ariaLabels[mode]);

                return input;
            }

            addInputListeners() {
                this.elements.fieldset.querySelectorAll('input[type="radio"]').forEach(input => {
                    // Handle mousedown for immediate response
                    input.addEventListener("mousedown", e => {
                        const mode = this.toy.state.get("mode");
                        const oldValue = this.toy.state.get(mode);
                        const newValue = parseInt(e.target.value);

                        // Only proceed if the value actually changed
                        if (oldValue !== newValue) {
                            // First calculate both angles
                            const oldAngle = this.getAngleForValue(oldValue, mode);
                            const newAngle = this.getAngleForValue(newValue, mode);

                            // Then update state
                            this.toy.state.setState({ [mode]: newValue });

                            // Finally regenerate with animation
                            this.regenerateInputsWithAnimation(oldAngle, newAngle);
                        }
                    });

                    // Handle change event to ensure proper focus state
                    input.addEventListener("change", e => {
                        if (e.target.checked) {
                            const mode = this.toy.state.get("mode");
                            const value = parseInt(e.target.value);
                            this.toy.state.setState({ [mode]: value });
                            this.toy.updateCheckedInput(value);
                            this.toy.focusCurrentValue();
                        }
                    });
                });
            }

            updateDisplay({ hue, saturation, lightness }) {
                const { root, componentValue } = this.elements;
                const mode = this.toy.state.get("mode");

                root.style.setProperty("--hue", hue);
                root.style.setProperty("--saturation", saturation);
                root.style.setProperty("--lightness", lightness);
                root.style.setProperty("--color-canvas", `hsl(${hue}, ${saturation}%, ${lightness}%)`);

                const dynamicColors = this.calculateDynamicColors(hue, saturation, lightness);
                root.style.setProperty("--color-dark", dynamicColors.background);
                root.style.setProperty("--color-light", dynamicColors.foreground);

                componentValue.textContent = this.toy.state.get(mode);

                // Update the hueyColor display
                const hueyColorElement = document.getElementById("hueyColor");
                if (hueyColorElement) {
                    hueyColorElement.textContent = `hsl(${hue}deg, ${saturation}%, ${lightness}%`;
                    // Add the closing parenthesis with tight spacing
                    const closeParen = document.createElement('span');
                    closeParen.className = 'ttm';
                    closeParen.textContent = ')';
                    hueyColorElement.appendChild(closeParen);
                }
            }

            calculateDynamicColors(hue, saturation, lightness) {
                const baseColor = utils.hslToRgb(hue, saturation, lightness);

                let backgroundLightness = 25;
                if (lightness > 80) backgroundLightness = 12;
                else if (lightness > 60) backgroundLightness = 18;
                else if (lightness > 40) backgroundLightness = 22;

                const backgroundSaturation = utils.clamp(saturation * 0.9, 40, 85);
                let backgroundColor = utils.hslToRgb(hue, backgroundSaturation, backgroundLightness);

                if (utils.getContrastRatio(baseColor, backgroundColor) < 4.5) {
                    backgroundLightness = Math.max(8, backgroundLightness - 5);
                    backgroundColor = utils.hslToRgb(hue, backgroundSaturation, backgroundLightness);
                }

                return {
                    background: `hsl(${hue}, ${backgroundSaturation}%, ${backgroundLightness}%)`,
                    foreground: `hsl(${hue}, ${Math.min(40, backgroundSaturation * 0.6)}%, 92%)`
                };
            }
        }

        class EventManager {
            constructor(toy) {
                this.toy = toy;
                this.keyHoldStart = 0;
                this.keyInterval = null;
                this.isDragging = false;
                this.startX = 0;
                this.startY = 0;
                this.lastX = 0;
                this.lastY = 0;
                this.oldAngleOnInteractionStart = null;
                this.boundMethods = this.bindMethods();
                this.cachedMeasurements = null;
                this.measurementTimeout = null;
            }

            // Cache the main element's measurements
            cacheMeasurements() {
                const rect = this.toy.elements.main.getBoundingClientRect();
                this.cachedMeasurements = {
                    centerX: rect.left + rect.width / 2,
                    centerY: rect.top + rect.height / 2,
                    timestamp: Date.now()
                };
            }

            // Get measurements, using cache if available and not too old
            getMeasurements() {
                const now = Date.now();
                // Cache is valid for 100ms
                if (!this.cachedMeasurements || now - this.cachedMeasurements.timestamp > 100) {
                    this.cacheMeasurements();
                }
                return this.cachedMeasurements;
            }

            handleDragStart(e) {
                e.preventDefault();

                const mode = this.toy.state.get("mode");
                const currentValue = this.toy.state.get(mode);
                this.oldAngleOnInteractionStart = this.toy.dom.getAngleForValue(currentValue, mode);

                this.isDragging = true;
                this.cacheMeasurements(); // Cache measurements at start of drag

                this.startX = e.touches ? e.touches[0].clientX : e.clientX;
                this.startY = e.touches ? e.touches[0].clientY : e.clientY;
                this.lastX = this.startX;
                this.lastY = this.startY;

                const { main, fieldset } = this.toy.elements;
                main.style.cursor = "grabbing";
                document.body.style.userSelect = "none";
                fieldset.classList.add("dragging");

                this.handleDragMove(e);
            }

            handleDragMove(e) {
                if (!this.isDragging) return;

                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                this.lastX = clientX;
                this.lastY = clientY;

                if (!this.rafPending) {
                    this.rafPending = true;
                    requestAnimationFrame(() => {
                        const { centerX, centerY } = this.getMeasurements();

                        const deltaX = this.lastX - centerX;
                        const deltaY = this.lastY - centerY;

                        const angle = (Math.atan2(deltaY, deltaX) * (180 / Math.PI) + 90 + 360) % 360;
                        const mode = this.toy.state.get("mode");
                        const value = utils.angleToValue(angle, mode);

                        const prevValue = this.toy.state.get(mode);
                        if (value !== prevValue) {
                            this.toy.state.setState({ [mode]: value });
                            this.toy.updateCheckedInput(value);
                        }
                        this.rafPending = false;
                    });
                }
            }

            handleDragEnd() {
                if (!this.isDragging) return;

                this.isDragging = false;
                this.rafPending = false;
                this.cachedMeasurements = null; // Clear cached measurements
                const { main, fieldset } = this.toy.elements;

                main.style.cursor = "";
                document.body.style.userSelect = "";

                const mode = this.toy.state.get("mode");
                const currentValue = this.toy.state.get(mode);
                const newAngle = this.toy.dom.getAngleForValue(currentValue, mode);

                const distance = Math.sqrt(Math.pow(this.lastX - this.startX, 2) + Math.pow(this.lastY - this.startY, 2));
                const clickThreshold = 5;

                if (distance >= clickThreshold) {
                    this.toy.dom.regenerateInputsWithAnimation(this.oldAngleOnInteractionStart, newAngle);
                }

                setTimeout(() => fieldset.classList.remove("dragging"), 300);
                this.oldAngleOnInteractionStart = null;
            }

            resetKeyHold() {
                console.log('Resetting key hold state');
                this.keyHoldStart = 0;
                if (this.keyInterval) {
                    console.log('Clearing acceleration interval');
                    clearInterval(this.keyInterval);
                    clearTimeout(this.keyInterval);
                    this.keyInterval = null;
                }
            }

            handleArrowNavigation(e) {
                // If this is a repeat event and we already have an interval, ignore it
                if (e.repeat && this.keyInterval) {
                    console.log('Ignoring repeat event - interval already running');
                    return;
                }

                // If this is the first keydown, start the hold timer
                if (this.keyHoldStart === 0) {
                    this.keyHoldStart = Date.now();
                    console.log('Starting key hold timer at:', this.keyHoldStart);
                    // Initial step (not accelerated)
                    const isForward = ["ArrowRight", "ArrowUp"].includes(e.key);
                    console.log('Initial step - direction:', isForward ? 'forward' : 'backward');
                    this.toy.navigateValue(isForward ? "forward" : "backward", false);
                }

                // If we don't have an interval yet, check if we should start one
                if (!this.keyInterval) {
                    const holdTime = Date.now() - this.keyHoldStart;
                    console.log('Current hold time:', holdTime, 'ms');
                    if (holdTime >= KEY_HOLD_DELAY) {
                        console.log('Starting acceleration after', holdTime, 'ms');
                        const isForward = ["ArrowRight", "ArrowUp"].includes(e.key);
                        // Start continuous updates with acceleration
                        this.keyInterval = setInterval(() => {
                            console.log('Accelerated step - direction:', isForward ? 'forward' : 'backward');
                            this.toy.navigateValue(isForward ? "forward" : "backward", true);
                        }, 100); // Update every 100ms when accelerated
                    }
                }
            }

            bindMethods() {
                return {
                    globalKeydown: this.handleGlobalKeydown.bind(this),
                    fieldsetKeydown: this.handleFieldsetKeydown.bind(this),
                    fieldsetKeyup: this.handleFieldsetKeyup.bind(this),
                    dragStart: this.handleDragStart.bind(this),
                    dragMove: this.handleDragMove.bind(this),
                    dragEnd: this.handleDragEnd.bind(this)
                };
            }

            addListeners() {
                const { elements } = this.toy;

                elements.copyBtn.addEventListener("click", () => this.toy.copyHSLToClipboard());
                elements.randomBtn.addEventListener("click", () => this.toy.generateRandomColor());
                elements.appTitle.addEventListener("click", () => this.toy.cycleModes());
                elements.appTitle.addEventListener("touchend", e => {
                    e.preventDefault();
                    this.toy.cycleModes();
                });

                // Use window with capture=true so global keydown shortcuts always work, even when inputs are focused
                window.addEventListener("keydown", this.boundMethods.globalKeydown, true);

                // Add fieldset keydown handler
                elements.fieldset.addEventListener("keydown", this.boundMethods.fieldsetKeydown);
                elements.fieldset.addEventListener("keyup", this.boundMethods.fieldsetKeyup);

                // Add blur handler to maintain checked state
                elements.fieldset.addEventListener("blur", (e) => {
                    // Only handle if the blur is from the fieldset itself
                    if (e.target === elements.fieldset) {
                        const mode = this.toy.state.get("mode");
                        const value = this.toy.state.get(mode);
                        // Re-check the input that should be checked
                        const targetInput = elements.fieldset.querySelector(`input[value="${value}"]`);
                        if (targetInput) {
                            targetInput.checked = true;
                            // Update the last checked angle when fieldset loses focus
                            this.toy.dom.lastCheckedAngle = this.toy.dom.getAngleForValue(value, mode);
                        }
                    }
                }, true);

                this.addDragListeners();
            }

            addDragListeners() {
                const { main } = this.toy.elements;

                main.addEventListener("mousedown", this.boundMethods.dragStart);
                document.addEventListener("mousemove", this.boundMethods.dragMove);
                document.addEventListener("mouseup", this.boundMethods.dragEnd);

                main.addEventListener("touchstart", this.boundMethods.dragStart, { passive: false });
                document.addEventListener("touchmove", this.boundMethods.dragMove, { passive: false });
                document.addEventListener("touchend", this.boundMethods.dragEnd);

                main.addEventListener("contextmenu", e => e.preventDefault());
            }

            handleGlobalKeydown(e) {
                // Tab switches mode (existing logic)
                if (e.key === "Tab" && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                    e.preventDefault();
                    this.toy.cycleModes();
                    return;
                }
                // Power user shortcuts: 'r' (random), 'c' (copy), 'h' (hue), 's' (saturation), 'l' (lightness)
                if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && !e.repeat) {
                    const tag = (e.target.tagName || '').toLowerCase();
                    if (tag !== 'input' && tag !== 'textarea' && !e.target.isContentEditable) {
                        if (e.key === 'r') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.generateRandomColor();
                            return;
                        } else if (e.key === 'c') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.copyHSLToClipboard();
                            return;
                        } else if (e.key === 'h') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.switchMode('hue');
                            return;
                        } else if (e.key === 's') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.switchMode('saturation');
                            return;
                        } else if (e.key === 'l') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.switchMode('lightness');
                            return;
                        }
                    }
                }
            }

            handleFieldsetKeydown(e) {
                const isArrowKey = ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown"].includes(e.key);
                const isHomeEnd = ["Home", "End"].includes(e.key);

                // If fieldset is transitioning modes, prevent keyboard navigation
                if (this.toy.elements.fieldset.classList.contains("mode-transitioning")) {
                    if (isArrowKey || isHomeEnd) {
                        e.preventDefault();
                        return;
                    }
                }

                // Power user shortcuts: 'r' (random), 'c' (copy), 'h' (hue), 's' (saturation), 'l' (lightness)
                if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && !e.repeat) {
                    const tag = (e.target.tagName || '').toLowerCase();
                    if (tag !== 'input' && tag !== 'textarea' && !e.target.isContentEditable) {
                        if (e.key === 'r') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.generateRandomColor();
                            return;
                        } else if (e.key === 'c') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.copyHSLToClipboard();
                            return;
                        } else if (e.key === 'h') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.switchMode('hue');
                            return;
                        } else if (e.key === 's') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.switchMode('saturation');
                            return;
                        } else if (e.key === 'l') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.toy.switchMode('lightness');
                            return;
                        }
                    }
                }

                if (!isArrowKey && !isHomeEnd) return;

                e.preventDefault();
                e.stopPropagation();
                const mode = this.toy.state.get("mode");
                const { min, max } = MODE_RANGES[mode];

                if (e.key === "Home") return this.toy.setValueAndFocus(min);
                if (e.key === "End") return this.toy.setValueAndFocus(max);

                // Handle arrow key navigation
                if (isArrowKey) {
                    const isForward = ["ArrowRight", "ArrowUp"].includes(e.key);

                    // If this is the first keydown (not a repeat)
                    if (!e.repeat) {
                        console.log('Initial keydown - no repeat');
                        // Reset any existing state
                        this.resetKeyHold();
                        // Start the hold timer
                        this.keyHoldStart = Date.now();
                        // Do a single step
                        this.toy.navigateValue(isForward ? "forward" : "backward", false);

                        // Only set up acceleration timer if we don't already have one
                        if (!this.keyInterval) {
                            this.keyInterval = setTimeout(() => {
                                if (this.keyHoldStart > 0) { // Only if key is still being held
                                    console.log('Starting acceleration');
                                    this.keyInterval = setInterval(() => {
                                        this.toy.navigateValue(isForward ? "forward" : "backward", true);
                                    }, 100);
                                }
                            }, KEY_HOLD_DELAY);
                        }
                    } else {
                        // For repeat events, just do single steps until acceleration kicks in
                        if (!this.keyInterval || typeof this.keyInterval === 'number') {
                            this.toy.navigateValue(isForward ? "forward" : "backward", false);
                        }
                    }
                }
            }

            handleFieldsetKeyup(e) {
                if (["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown"].includes(e.key)) {
                    this.resetKeyHold();
                }
            }
        }

        class HSLColorToy {
            constructor() {
                this.state = new ColorState(initialColor);
                this.dom = new DOMManager(this);
                this.elements = this.dom.elements;
                this.currentCheckedInputRef = null;
                this.eventManager = new EventManager(this);
                this.init();
            }

            init() {
                this.state.subscribe(state => this.dom.updateDisplay(state));
                this.dom.generateInputs(this.state.get("mode"));
                this.dom.addInputListeners();
                this.setInitialState();
                this.eventManager.addListeners();

                // Add a live region to announce color changes
                const liveRegion = document.createElement('div');
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.className = 'vh';
                document.body.appendChild(liveRegion);
            }

            setInitialState() {
                console.log("setInitialState: Initializing with mode=", this.state.get("mode"), "value=", this.state.get(this.state.get("mode")));
                const mode = this.state.get("mode");
                const value = this.state.get(mode);

                this.dom.updateModeDisplay(mode);

                // First clear and regenerate inputs
                this.dom.elements.fieldset.innerHTML = "";
                this.dom.generateInputs(mode);
                this.dom.addInputListeners();

                // Then update checked state and focus
                this.updateCheckedInput(value);
                this.focusCurrentValue();

                this.dom.updateDisplay(this.state.get());
                this.dom.lastCheckedAngle = this.dom.getAngleForValue(value, mode);

                this.elements.fieldset.style.display = 'grid';
                this.elements.fieldset.style.visibility = 'visible';

                setTimeout(() => {
                    this.dom.isInitialized = true;
                }, 100);
            }

            cycleModes() {
                const currentIndex = MODES.indexOf(this.state.get("mode"));
                const nextMode = MODES[(currentIndex + 1) % MODES.length];
                this.switchMode(nextMode);
            }

            switchMode(newMode) {
                console.log(`switchMode: Switching from ${this.state.get("mode")} to ${newMode}`);
                const oldMode = this.state.get("mode");
                const oldValue = this.state.get(oldMode);
                const oldAngle = this.dom.getAngleForValue(oldValue, oldMode);

                this.state.setState({ mode: newMode });
                this.dom.updateModeDisplay(newMode);

                const newValue = this.state.get(newMode);
                const newAngle = this.dom.getAngleForValue(newValue, newMode);

                // Ensure the fieldset has focus after mode switch
                this.elements.fieldset.focus();

                this.dom.regenerateInputsWithAnimation(oldAngle, newAngle);

                // Ensure focus is maintained after regeneration
                setTimeout(() => {
                    this.elements.fieldset.focus();
                    this.focusCurrentValue();
                }, 600); // Wait for animation to complete
            }

            setValueAndFocus(value) {
                console.log("setValueAndFocus: Setting value to", value);
                const mode = this.state.get("mode");
                this.state.setState({ [mode]: value });
                this.updateCheckedInput(value);
                this.focusCurrentValue();
            }

            updateCheckedInput(value) {
                const mode = this.state.get("mode");
                const fieldset = this.elements.fieldset;

                // First, uncheck ALL inputs in the current mode
                fieldset.querySelectorAll(`input[name="${mode.charAt(0)}"]`).forEach(input => {
                    input.checked = false;
                });

                // Then check the target input
                const targetInput = fieldset.querySelector(`input[value="${value}"]`);
                if (targetInput) {
                    targetInput.checked = true;
                }
            }

            focusCurrentValue() {
                const mode = this.state.get("mode");
                const value = this.state.get(mode);
                const targetInput = this.elements.fieldset.querySelector(`input[value="${value}"]`);
                if (targetInput) {
                    targetInput.checked = true;
                    targetInput.focus();
                }
            }

            navigateValue(direction, isAccelerated = false) {
                console.log("navigateValue: Direction:", direction, "Accelerated:", isAccelerated);
                const mode = this.state.get("mode");
                const currentValue = this.state.get(mode);
                console.log("navigateValue: Current value for mode", mode, ":", currentValue);

                let step;
                // Define acceleration steps based on mode
                if (mode === "hue") {
                    step = isAccelerated ? 9 : 1; // Hue: 1 to 9 degrees
                } else {
                    step = isAccelerated ? 3 : 1; // S/L: 1 to 3 percent
                }
                console.log("navigateValue: Current value:", currentValue, "Step:", step);

                const { min, max } = MODE_RANGES[mode];

                let newValue;
                if (direction === "forward") {
                    newValue = currentValue + step;
                    if (mode === "hue") {
                        newValue = (newValue > max) ? (newValue - 360) : newValue;
                    } else {
                        newValue = (newValue > max) ? min : newValue;
                    }
                } else {
                    newValue = currentValue - step;
                    if (mode === "hue") {
                        newValue = (newValue < min) ? (360 + newValue) : newValue;
                    } else {
                        newValue = (newValue < min) ? max : newValue;
                    }
                }
                console.log("navigateValue: New value calculated:", newValue);

                this.setValueAndFocus(newValue);
            }

            generateRandomColor() {
                console.log("generateRandomColor: Generating a new random color.");
                const currentMode = this.state.get("mode");
                const oldValue = this.state.get(currentMode);
                const oldAngle = this.dom.getAngleForValue(oldValue, currentMode);

                this.state.setState({
                    hue: Math.floor(360 * Math.random()) + 1,
                    saturation: Math.floor(101 * Math.random()),
                    lightness: Math.floor(101 * Math.random())
                });

                const newValue = this.state.get(currentMode);
                const newAngle = this.dom.getAngleForValue(newValue, currentMode);

                // Use regenerateInputsWithAnimation to handle both animation and input state
                this.dom.regenerateInputsWithAnimation(oldAngle, newAngle);
            }

            async copyHSLToClipboard() {
                console.log("copyHSLToClipboard: Attempting to copy HSL to clipboard.");
                const { hue, saturation, lightness } = this.state.get();
                const hslString = `hsl(${hue}deg, ${saturation}%, ${lightness}%)`;

                try {
                    await navigator.clipboard.writeText(hslString);
                    this.showCopySuccess();
                    console.log("copyHSLToClipboard: Successfully copied:", hslString);
                } catch (error) {
                    this.fallbackCopy(hslString);
                    this.showCopySuccess();
                    console.error("copyHSLToClipboard: Failed to copy, falling back:", error);
                }
            }

            fallbackCopy(text) {
                console.log("fallbackCopy: Using fallback copy method.");
                const textarea = Object.assign(document.createElement("textarea"), { value: text });
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand("copy");
                document.body.removeChild(textarea);
            }

            showCopySuccess() {
                console.log("showCopySuccess: Showing copy success animation.");
                this.elements.copyBtn.classList.add("copy-success");
                setTimeout(() => this.elements.copyBtn.classList.remove("copy-success"), 1000);
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            try {
                new HSLColorToy();
                console.log("HSL Color Toy initialized successfully.");
            } catch (error) {
                console.error("Error initializing HSL Color Toy:", error);
            }
        });

        // Add more descriptive keyboard shortcuts
        const keyboardShortcuts = {
            'h': 'Switch to Hue mode',
            's': 'Switch to Saturation mode',
            'l': 'Switch to Lightness mode',
            'r': 'Generate random color',
            'c': 'Copy current color'
        };
    </script>
</body>

</html>
