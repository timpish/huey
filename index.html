<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Huey—HSL Color Toy</title>
    <style>
        :root {
            --hue: 360;
            --saturation: 100;
            --lightness: 50;
            --color-canvas: hsl(var(--hue), calc(var(--saturation) * 1%), calc(var(--color-lightness) * 1%));
            --color-light: hsl(var(--hue), 80%, 95%);
            --color-dark: hsl(var(--hue), 80%, 25%);
            --color-action-default: hsl(var(--hue), 80%, 98%);
            --color-action-hover: hsl(var(--hue), 40%, 87%);
            --color-action-active: hsl(var(--hue), 35%, 80%);
            --color-shadow: var(--hue) 3% 10%;

            --typography-typeface-monospace: ui-monospace, monospace;
            --typography-typeface-sans: system-ui, sans-serif;
            --typography-size-xl: clamp(3rem, 1.5714rem + 7.1429vw, 8rem);
            --typography-size-l: clamp(2.5rem, 2.3571rem + 0.7143vw, 3rem);
            --typography-size-s: clamp(0.8125rem, 0.7768rem + 0.1786vw, 0.9375rem);
            --typography-size-icon: clamp(2.4cap, 2.357cap + 0.036vw, 2.8cap);
            --typography-leading-open: 1.5;
            --typography-leading-tight: 1;

            --spacing-xs: clamp(0.25rem, 0.1786rem + 0.3571vw, 0.5rem);
            --spacing-s: clamp(0.375rem, 0.3393rem + 0.1786vw, 0.5rem);
            --spacing-m: clamp(0.375rem, 0.3036rem + 0.3571vw, 0.625rem);
            --spacing-l: clamp(0.5rem, 0.3571rem + 0.7143vw, 1rem);
            --spacing-xl: clamp(1.375rem, 1.3036rem + 0.3571vw, 1.625rem);

            --circle: 50%;
            --corner: .6rem;
            --diameter: 35vmin;
            --shadow-strength: 1%;
            --shadow:
                0 -2px 5px 0 hsl(var(--color-shadow) / calc(var(--shadow-strength) + 2%)),
                0 1px 1px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 3%)),
                0 2px 2px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 3%)),
                0 5px 5px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 4%)),
                0 9px 9px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 5%)),
                0 16px 16px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 6%));
            --top: 999;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }


        html {
            block-size: 100%;
            -moz-text-size-adjust: none;
            -webkit-text-size-adjust: none;
            text-size-adjust: none;
        }

        body {
            background-color: var(--color-canvas);
            font-family: var(--typography-typeface-sans);
            line-height: var(--typography-leading-open);
            min-block-size: 100%;
            transition: background-color 80ms;
        }

        h1 {
            background-color: var(--color-dark);
            color: var(--color-light);
            border-radius: 0 0 var(--corner) var(--corner);
            font-family: var(--typography-typeface-monospace);
            font-size: var(--typography-size-l);
            line-height: var(--typography-leading-tight);
            padding-block: .5rem .8rem;
            padding-inline: var(--spacing-xl);
        }

        button {
            align-items: center;
            background-color: var(--color-action-default);
            border: 3px solid var(--color-dark);
            border-radius: var(--circle);
            box-shadow: var(--shadow);
            color: var(--color-dark);
            cursor: pointer;
            display: inline-flex;
            font: inherit;
            padding: var(--spacing-s);
            margin: var(--spacing-m);
            touch-action: manipulation;
            transition-property: background-color, outline;
            transition-duration: 180ms;
            transition-timing-function: ease-in-out;
        }

        button:hover {
            background-color: var(--color-action-hover);
        }

        :where(button:active, button:focus-visible) {
            outline: 5px solid hsla(var(--hue) 80% 25% / .5);
            outline-offset: -1px;
        }

        button:active {
            background-color: var(--color-action-active);
        }

        main {
            position: relative;
            height: var(--diameter);
            width: var(--diameter);
        }

        fieldset {
            --cell-size: fit-content;
            --offset: calc(360deg / var(--i-count));
            position: absolute;
            top: 0;
            left: 0;
            display: grid;
            grid: var(--cell-size) / var(--cell-size);
            place-content: center;
            height: 100%;
            width: 100%;
            border: none;
            padding: 0 !important;
        }

        fieldset>* {
            grid-area: 1/1;
        }

        input {
            --angle: calc((var(--i) * var(--offset)) - 90deg);
            appearance: none;
            border-radius: var(--circle);
            cursor: pointer;
            height: 2.75rem;
            width: 2.75rem;
            touch-action: manipulation;
            translate: calc(cos(var(--angle)) * var(--diameter)) calc(sin(var(--angle)) * var(--diameter));
        }

        /* :where(input:checked, input:focus, input:checked:focus, input:hover) {
            outline: 3px solid white;
            z-index: var(--top);
        } */

        :where(input:checked, input:focus-visible, input:hover) {
            outline: 3px solid white;
            z-index: var(--top);
        }

        input:focus {
            z-index: var(--top);
        }

        .mode-hue input {
            background: hsl(calc(var(--i) * 1deg), 100%, 50%);
        }

        .mode-saturation input {
            background: hsl(var(--hue), calc(var(--i) * 1%), 50%);
        }

        .mode-lightness input {
            background: hsl(var(--hue), calc(var(--saturation) * 1%), calc(var(--i) * 1%));
        }

        .value-display {
            position: absolute;
            top: 50%;
            left: 50%;
            height: fit-content;
            width: fit-content;
            overflow: visible;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: var(--top);
        }

        text {
            fill: var(--color-light);
            font-size: var(--typography-size-xl);
            font-weight: bold;
            dominant-baseline: central;
            text-anchor: middle;
            paint-order: stroke;
            stroke: var(--color-dark);
            stroke-width: 3px;
            stroke-linejoin: round;
        }

        a {
            color: currentColor;
            text-decoration-color: currentColor;
            text-underline-offset: .25ex;
            text-decoration-thickness: .05ex;
        }

        a:hover {
            text-decoration-thickness: .10ex;
        }

        :where(abbr[title]) {
            cursor: help;
            text-decoration-line: underline;
            text-decoration-style: dotted;
        }

        footer small {
            background-color: var(--color-dark);
            border-radius: 0 var(--corner) 0 0;
            color: var(--color-light);
            display: inline-block;
            font-size: var(--typography-size-s);
            padding-block: var(--spacing-xs);
            padding-inline: var(--spacing-l);
        }

        footer small:last-of-type {
            border-radius: var(--corner) 0 0 0;
        }

        .center {
            box-sizing: content-box;
            margin-inline: auto;
            max-inline-size: none;
            text-align: center;
        }

        .cover {
            display: flex;
            flex-direction: column;
            min-block-size: 100vh;
        }

        .cover>* {
            margin-block: 0;
        }

        .cover> :first-child:not(main) {
            margin-block-start: 0;
        }

        .cover> :last-child:not(main) {
            margin-block-end: 0;
        }

        .cover>main {
            margin-block: auto;
        }

        .with-icon {
            display: inline-flex;
            align-items: center;
        }

        .icon {
            height: 2.6cap;
            width: 2.6cap;
            transition: opacity 300ms ease-in-out 240ms;
        }

        .with-icon .icon {
            margin-inline-end: 0;
        }

        .icon-check {
            opacity: 0;
            position: absolute;
        }

        .copy-success .icon-copy {
            opacity: 0;
        }

        .copy-success .icon-check {
            opacity: 1;
        }

        .stack-x {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-l);
            align-items: flex-start;
            justify-content: space-between;
        }

        .visually-hidden:not(:focus):not(:active):not(:focus-within) {
            clip-path: inset(50%);
            block-size: 1px;
            inline-size: 1px;
            overflow: hidden;
            position: absolute !important;
            white-space: nowrap;
        }
    </style>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="author" content="Timothy Martens">
    <meta name="description" content="Huey—HSL Color Toy">
</head>

<body class="center cover">

    <header class="stack-x">
        <button class="with-icon" id="random-btn">
            <svg class="icon" aria-hidden="true">
                <use href="#icon-random"></use>
            </svg>
            <span class="visually-hidden">Refresh</span>
        </button>
        <h1 class="mode-title">H</h1>
        <button class="with-icon" id="copy-btn">
            <svg class="icon icon-copy" aria-hidden="true">
                <use href="#icon-copy"></use>
            </svg>
            <svg class="icon icon-check" aria-hidden="true">
                <use href="#icon-check"></use>
            </svg>
            <span class="visually-hidden">Copy/Confirm Copy</span>
        </button>
    </header>

    <main class="center">
        <fieldset style="--i-count:360" role="radiogroup" aria-label="Color component selector" aria-labelledby="mode-title" aria-describedby="color-instructions">
        </fieldset>
        <svg class="value-display" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" aria-hidden="true">
            <text x="50" y="50" class="component-value">360</text>
        </svg>
    </main>

    <div id="color-instructions" class="visually-hidden">
        <p>Use arrow keys to adjust the selected color component. Press Tab to switch between Hue, Saturation, and Lightness modes. Press Home or End to jump to minimum or maximum values. Hold down arrow keys for faster navigation.</p>
    </div>

    <footer class="stack-x">
        <small>HUEy&mdash;<abbr title="Hue, Saturation, Lightness">HSL</abbr> color toy</small>
        <small>&copy; &apos;25 <a href="https://timpish.com" aria-label="Visit Timothy Martens' website">Timothy Martens</a></small>
    </footer>

    <svg class="visually-hidden" display="none" aria-hidden="true" height="0" width="0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <symbol id="icon-random" title="Random Color Icon" viewBox="0 0 256 256">
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="M32 72h23.06a64 64 0 0 1 52.08 26.8l41.72 58.4a64 64 0 0 0 52.08 26.8H232M208 48l24 24-24 24" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="m208 160 24 24-24 24M152.77 93.86A64 64 0 0 1 200.94 72H232M32 184h23.06a64 64 0 0 0 48.17-21.86" />
            </symbol>
            <symbol id="icon-copy" title="Copy Color Icon" viewBox="0 0 256 256">
                <path fill="none" d="M0 0h256v256H0z" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="M40 76h140v140H40z" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="M76 40h140v140" />
            </symbol>
            <symbol id="icon-check" title="Confirm Copy Color Icon" viewBox="0 0 256 256">
                <path fill="none" d="M0 0h256v256H0z" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="m40 144 56 56L224 72" />
            </symbol>
        </defs>
    </svg>

    <script>
        /**
         * HSL Color Toy - Enhanced with reliable tab switching and debouncing
         */

        class HSLColorToy {
            constructor() {
                this.state = {
                    hue: 360,
                    saturation: 100,
                    lightness: 50,
                    mode: 'hue'
                };

                this.modes = ['hue', 'saturation', 'lightness'];
                this.keyHoldStart = 0;

                // Debounce timers
                this.regenerationTimer = null;
                this.REGENERATION_DELAY = 150; // ms

                // DOM elements cache
                this.elements = {};

                this.init();
            }

            /**
             * Initialize the color toy
             */
            init() {
                this.cacheElements();
                this.generateInputs();
                this.addEventListeners();
                this.setInitialState();
            }

            /**
             * Cache frequently used DOM elements
             */
            cacheElements() {
                this.elements = {
                    root: document.documentElement,
                    fieldset: document.querySelector('fieldset'),
                    appTitle: document.querySelector('.mode-title'),
                    componentValue: document.querySelector('.component-value'),
                    copyBtn: document.getElementById('copy-btn'),
                    randomBtn: document.getElementById('random-btn')
                };
            }

            /**
             * Set initial application state
             */
            setInitialState() {
                this.switchMode(this.state.mode);
                const currentValue = this.state[this.state.mode];
                const initialRadio = this.elements.fieldset.querySelector(`input[value="${currentValue}"]`);

                if (initialRadio) {
                    initialRadio.checked = true;
                    initialRadio.focus();
                }

                this.updateDisplay();
            }

            /**
             * Add all event listeners
             */
            addEventListeners() {
                // Button listeners
                this.elements.copyBtn.addEventListener('click', () => this.copyHSLToClipboard());
                this.elements.randomBtn.addEventListener('click', () => this.generateRandomColor());

                // Keyboard navigation
                document.addEventListener('keydown', (e) => this.handleGlobalKeydown(e));
                this.elements.fieldset.addEventListener('keydown', (e) => this.handleFieldsetKeydown(e));
                this.elements.fieldset.addEventListener('keyup', (e) => this.handleFieldsetKeyup(e));
                this.elements.fieldset.addEventListener('blur', () => this.resetKeyHold());

                // Input change listeners
                this.addInputListeners();
            }

            /**
             * Handle global keyboard events (Tab for mode switching)
             */
            handleGlobalKeydown(e) {
                // Handle Tab key for mode switching (works anywhere in the document)
                if (e.key === 'Tab' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                    e.preventDefault();

                    const currentIndex = this.modes.indexOf(this.state.mode);
                    const nextIndex = (currentIndex + 1) % this.modes.length;
                    this.switchMode(this.modes[nextIndex]);

                    // Always ensure focus is properly set after mode switch
                    this.ensureFocusAfterModeSwitch();
                    return;
                }
            }

            /**
             * Ensure proper focus after mode switching
             */
            ensureFocusAfterModeSwitch() {
                // Small delay to ensure DOM has updated after mode switch
                setTimeout(() => {
                    const currentValue = this.state[this.state.mode];
                    const targetInput = this.elements.fieldset.querySelector(`input[value="${currentValue}"]`);

                    if (targetInput) {
                        targetInput.checked = true;
                        targetInput.focus();
                    } else {
                        // Fallback: focus the fieldset itself
                        this.elements.fieldset.focus();
                    }
                }, 10);
            }

            /**
             * Handle fieldset keyboard navigation
             */
            handleFieldsetKeydown(e) {
                const isArrowKey = ['ArrowRight', 'ArrowUp', 'ArrowLeft', 'ArrowDown'].includes(e.key);
                const isHomeEnd = ['Home', 'End'].includes(e.key);

                if (!isArrowKey && !isHomeEnd) return;
                e.preventDefault();

                const { min, max } = this.getModeRange(this.state.mode);

                // Handle Home/End for quick navigation
                if (e.key === 'Home') {
                    this.setValueAndFocus(min);
                    return;
                }

                if (e.key === 'End') {
                    this.setValueAndFocus(max);
                    return;
                }

                // Handle arrow keys with acceleration
                this.handleArrowNavigation(e);
            }

            /**
             * Handle arrow key navigation with acceleration
             */
            handleArrowNavigation(e) {
                if (this.keyHoldStart === 0) {
                    this.keyHoldStart = Date.now();
                }

                const holdDuration = Date.now() - this.keyHoldStart;
                const useAcceleration = holdDuration > 1500;
                const isForward = e.key === 'ArrowRight' || e.key === 'ArrowUp';

                this.navigateValue(isForward ? 'forward' : 'backward', useAcceleration);
            }

            /**
             * Handle fieldset key release
             */
            handleFieldsetKeyup(e) {
                const isArrowKey = ['ArrowRight', 'ArrowUp', 'ArrowLeft', 'ArrowDown'].includes(e.key);
                if (isArrowKey) {
                    this.resetKeyHold();
                }
            }

            /**
             * Reset key hold timer
             */
            resetKeyHold() {
                this.keyHoldStart = 0;
            }

            /**
             * Get min/max range for current mode
             */
            getModeRange(mode) {
                switch (mode) {
                    case 'hue':
                        return { min: 1, max: 360 };
                    case 'saturation':
                        return { min: 0, max: 100 };
                    case 'lightness':
                        return { min: 1, max: 100 };
                    default:
                        return { min: 0, max: 100 };
                }
            }

            /**
             * Set a value and focus the corresponding input
             */
            setValueAndFocus(value) {
                const radio = this.elements.fieldset.querySelector(`input[value="${value}"]`);
                if (radio) {
                    radio.checked = true;
                    radio.focus();
                    this.state[this.state.mode] = value;
                    this.updateDisplay();
                }
            }

            /**
             * Navigate to next/previous value with optional acceleration
             */
            navigateValue(direction, accelerated = false) {
                const checked = this.elements.fieldset.querySelector('input:checked');
                if (!checked) return;

                const currentValue = parseInt(checked.value);
                const mode = this.state.mode;
                const increment = accelerated ? 9 : 1;
                const { min, max } = this.getModeRange(mode);

                let newValue;

                if (direction === 'forward') {
                    newValue = currentValue + increment;
                    if (newValue > max) {
                        newValue = mode === 'hue' ? newValue - 360 : min;
                    }
                } else {
                    newValue = currentValue - increment;
                    if (newValue < min) {
                        newValue = mode === 'hue' ? 360 + newValue : max;
                    }
                }

                this.setValueAndFocus(newValue);
            }

            /**
             * Switch between hue, saturation, and lightness modes with debouncing
             */
            switchMode(newMode) {
                const previousMode = this.state.mode;
                this.state.mode = newMode;
                this.updateModeDisplay(newMode);

                // Debounce the expensive regeneration operation
                this.debouncedRegeneration();

                // Update display immediately for visual feedback
                this.updateDisplay();

                // Log mode switch for debugging
                console.log(`Mode switched: ${previousMode} → ${newMode}`);
            }

            /**
             * Debounced regeneration to prevent excessive DOM manipulation
             */
            debouncedRegeneration() {
                // Clear existing timer
                if (this.regenerationTimer) {
                    clearTimeout(this.regenerationTimer);
                }

                // Set new timer
                this.regenerationTimer = setTimeout(() => {
                    this.regenerateInputs();
                    this.regenerationTimer = null;
                }, this.REGENERATION_DELAY);
            }

            /**
             * Update mode-specific display elements with visual feedback
             */
            updateModeDisplay(mode) {
                const modeLabels = {
                    hue: 'H',
                    saturation: 'S',
                    lightness: 'L'
                };

                this.elements.appTitle.textContent = modeLabels[mode];
                this.elements.fieldset.className = `center mode-${mode}`;
                this.elements.fieldset.setAttribute('aria-label', `${mode} selector`);

                // Add a brief visual flash to indicate mode change
                this.elements.appTitle.style.transform = 'scale(1.1)';
                this.elements.appTitle.style.transition = 'transform 0.15s ease-out';
                setTimeout(() => {
                    this.elements.appTitle.style.transform = 'scale(1)';
                }, 150);
            }

            /**
             * Regenerate inputs for current mode with enhanced focus preservation
             */
            regenerateInputs() {
                // Store current focus state and value
                const hadFocus = this.elements.fieldset.contains(document.activeElement);
                const currentValue = this.state[this.state.mode];

                // Clear and regenerate
                this.elements.fieldset.innerHTML = '';
                this.generateInputs();
                this.addInputListeners();

                // Always restore checked state and focus if needed
                const targetInput = this.elements.fieldset.querySelector(`input[value="${currentValue}"]`);
                if (targetInput) {
                    targetInput.checked = true;
                    if (hadFocus) {
                        // Use requestAnimationFrame to ensure DOM is fully updated
                        requestAnimationFrame(() => {
                            targetInput.focus();
                        });
                    }
                }
            }

            /**
             * Generate radio inputs based on current mode
             */
            generateInputs() {
                const mode = this.state.mode;
                const { min, max } = this.getModeRange(mode);

                // Set CSS custom property for input count
                const inputCount = mode === 'hue' ? 360 : 100;
                this.elements.fieldset.style.setProperty('--i-count', inputCount.toString());

                // Use document fragment for better performance
                const fragment = document.createDocumentFragment();

                for (let i = min; i <= max; i++) {
                    const input = this.createRadioInput(i, mode);
                    fragment.appendChild(input);
                }

                this.elements.fieldset.appendChild(fragment);
            }

            /**
             * Create a single radio input element
             */
            createRadioInput(value, mode) {
                const input = document.createElement('input');
                input.type = 'radio';
                input.name = mode.charAt(0);
                input.value = value;
                input.style.setProperty('--i', value);

                const labels = {
                    hue: `${value} degrees`,
                    saturation: `${value} percent saturation`,
                    lightness: `${value} percent lightness`
                };

                input.setAttribute('aria-label', labels[mode]);
                return input;
            }

            /**
             * Add change listeners to all radio inputs
             */
            addInputListeners() {
                const inputs = this.elements.fieldset.querySelectorAll('input[type="radio"]');
                inputs.forEach((input) => {
                    input.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.state[this.state.mode] = parseInt(e.target.value);
                            this.updateDisplay();
                            e.target.focus();
                        }
                    });
                });
            }

            /**
             * Update all visual elements with current color state
             */
            updateDisplay() {
                this.updateCSSProperties();
                this.updateColorValues();
                this.updateDisplayText();
            }

            /**
             * Update CSS custom properties
             */
            updateCSSProperties() {
                const { hue, saturation, lightness } = this.state;
                const root = this.elements.root;

                root.style.setProperty('--hue', hue);
                root.style.setProperty('--saturation', saturation);
                root.style.setProperty('--lightness', lightness);
                root.style.setProperty('--color-canvas', `hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }

            /**
             * Update dynamic header/footer colors
             */
            updateColorValues() {
                const { hue, saturation, lightness } = this.state;
                const dynamicColors = this.calculateDynamicColors(hue, saturation, lightness);

                this.elements.root.style.setProperty('--color-dark', dynamicColors.background);
                this.elements.root.style.setProperty('--color-light', dynamicColors.foreground);
            }

            /**
             * Update the central display text
             */
            updateDisplayText() {
                const currentValue = this.state[this.state.mode];
                this.elements.componentValue.textContent = currentValue;
            }

            /**
             * Calculate optimal header/footer colors with proper contrast
             */
            calculateDynamicColors(hue, saturation, lightness) {
                const mainRgb = this.hslToRgb(hue, saturation, lightness);

                // Calculate header lightness based on main color lightness
                let headerLightness;
                if (lightness > 80) headerLightness = 12;
                else if (lightness > 60) headerLightness = 18;
                else if (lightness > 40) headerLightness = 22;
                else headerLightness = 25;

                const headerSaturation = Math.min(85, Math.max(40, saturation * 0.9));
                let headerBgRgb = this.hslToRgb(hue, headerSaturation, headerLightness);
                let contrast = this.getContrastRatio(mainRgb, headerBgRgb);

                // Ensure sufficient contrast
                if (contrast < 4.5) {
                    headerLightness = Math.max(8, headerLightness - 5);
                    headerBgRgb = this.hslToRgb(hue, headerSaturation, headerLightness);
                }

                // Light text colors
                const fgLightness = 92;
                const fgSaturation = Math.min(40, headerSaturation * 0.6);

                return {
                    background: `hsl(${hue}, ${headerSaturation}%, ${headerLightness}%)`,
                    foreground: `hsl(${hue}, ${fgSaturation}%, ${fgLightness}%)`
                };
            }

            /**
             * Generate a random vibrant color
             */
            generateRandomColor() {
                // Generate vibrant, well-balanced random colors
                this.state.hue = Math.floor(Math.random() * 360) + 1;
                this.state.saturation = Math.floor(Math.random() * 21) + 80; // 80-100%
                this.state.lightness = Math.floor(Math.random() * 21) + 40;  // 40-60%

                this.updateDisplay();

                // Update the current mode's input
                const currentValue = this.state[this.state.mode];
                const targetInput = this.elements.fieldset.querySelector(`input[value="${currentValue}"]`);
                if (targetInput) {
                    targetInput.checked = true;
                    targetInput.focus();
                }
            }

            /**
             * Copy HSL color value to clipboard
             */
            async copyHSLToClipboard() {
                const { hue, saturation, lightness } = this.state;
                const hslString = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

                try {
                    await navigator.clipboard.writeText(hslString);
                    this.showCopySuccess();
                } catch (err) {
                    console.error('Failed to copy color to clipboard:', err);
                    this.fallbackCopy(hslString);
                    this.showCopySuccess();
                }
            }

            /**
             * Fallback copy method for older browsers
             */
            fallbackCopy(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
            }

            /**
             * Show copy success animation
             */
            showCopySuccess() {
                this.elements.copyBtn.classList.add('copy-success');
                setTimeout(() => {
                    this.elements.copyBtn.classList.remove('copy-success');
                }, 1000);
            }

            // Color utility methods

            /**
             * Convert HSL to RGB
             */
            hslToRgb(h, s, l) {
                s /= 100;
                l /= 100;

                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;
                let r = 0, g = 0, b = 0;

                if (0 <= h && h < 60) {
                    r = c; g = x; b = 0;
                } else if (60 <= h && h < 120) {
                    r = x; g = c; b = 0;
                } else if (120 <= h && h < 180) {
                    r = 0; g = c; b = x;
                } else if (180 <= h && h < 240) {
                    r = 0; g = x; b = c;
                } else if (240 <= h && h < 300) {
                    r = x; g = 0; b = c;
                } else if (300 <= h && h < 360) {
                    r = c; g = 0; b = x;
                }

                return {
                    r: Math.round((r + m) * 255),
                    g: Math.round((g + m) * 255),
                    b: Math.round((b + m) * 255)
                };
            }

            /**
             * Calculate relative luminance (WCAG formula)
             */
            getRelativeLuminance(r, g, b) {
                // Convert RGB to 0-1 range
                r /= 255;
                g /= 255;
                b /= 255;

                // Apply gamma correction
                r = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
                g = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
                b = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);

                return 0.2126 * r + 0.7152 * g + 0.0722 * b;
            }

            /**
             * Calculate contrast ratio between two colors
             */
            getContrastRatio(rgb1, rgb2) {
                const l1 = this.getRelativeLuminance(rgb1.r, rgb1.g, rgb1.b);
                const l2 = this.getRelativeLuminance(rgb2.r, rgb2.g, rgb2.b);

                const lighter = Math.max(l1, l2);
                const darker = Math.min(l1, l2);

                return (lighter + 0.05) / (darker + 0.05);
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            try {
                new HSLColorToy();
            } catch (error) {
                console.error('Error initializing HSL Color Toy:', error);
            }
        });
    </script>

</body>

</html>