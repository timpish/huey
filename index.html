<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hueyâ€”HSL Color Toy</title>
    <style>
        :root {
            --hue: 360;
            --saturation: 100;
            --lightness: 50;
            --color-canvas: hsl(var(--hue), calc(var(--saturation) * 1%), calc(var(--color-lightness) * 1%));
            --color-light: hsl(var(--hue), 80%, 95%);
            --color-dark: hsl(var(--hue), 80%, 25%);
            --color-action-default: hsl(var(--hue), 80%, 98%);
            --color-action-hover: hsl(var(--hue), 40%, 87%);
            --color-action-active: hsl(var(--hue), 35%, 80%);
            --color-shadow: var(--hue) 3% 10%;

            --typography-typeface-monospace: ui-monospace, monospace;
            --typography-typeface-sans: system-ui, sans-serif;
            --typography-size-xl: clamp(3rem, 1.5714rem + 7.1429vw, 8rem);
            --typography-size-l: clamp(2.5rem, 2.3571rem + 0.7143vw, 3rem);
            --typography-size-s: clamp(0.8125rem, 0.7768rem + 0.1786vw, 0.9375rem);
            --typography-size-icon: clamp(2.4cap, 2.357cap + 0.036vw, 2.8cap);
            --typography-leading-open: 1.5;
            --typography-leading-tight: 1;

            --spacing-xs: clamp(0.25rem, 0.1786rem + 0.3571vw, 0.5rem);
            --spacing-s: clamp(0.375rem, 0.3393rem + 0.1786vw, 0.5rem);
            --spacing-m: clamp(0.375rem, 0.3036rem + 0.3571vw, 0.625rem);
            --spacing-l: clamp(0.5rem, 0.3571rem + 0.7143vw, 1rem);
            --spacing-xl: clamp(1.375rem, 1.3036rem + 0.3571vw, 1.625rem);

            --circle: 50%;
            --corner: .6rem;
            --diameter: 35vmin;
            --shadow-strength: 1%;
            --shadow:
                0 -2px 5px 0 hsl(var(--color-shadow) / calc(var(--shadow-strength) + 2%)),
                0 1px 1px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 3%)),
                0 2px 2px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 3%)),
                0 5px 5px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 4%)),
                0 9px 9px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 5%)),
                0 16px 16px -2px hsl(var(--color-shadow) / calc(var(--shadow-strength) + 6%));
            --top: 999;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            block-size: 100%;
            -moz-text-size-adjust: none;
            -webkit-text-size-adjust: none;
            text-size-adjust: none;
        }

        body {
            background-color: var(--color-canvas);
            font-family: var(--typography-typeface-sans);
            line-height: var(--typography-leading-open);
            min-block-size: 100%;
            transition: background-color 80ms;
        }

        h1 {
            background-color: var(--color-dark);
            border-radius: 0 0 var(--corner) var(--corner);
            color: var(--color-action-default);
            cursor: pointer;
            font-family: var(--typography-typeface-monospace);
            font-size: var(--typography-size-l);
            line-height: var(--typography-leading-tight);
            padding-block: .5rem .8rem;
            padding-inline: var(--spacing-xl);
            transition: transform 120ms ease-in-out;
            user-select: none;
        }

        h1:hover {
            color: var(--color-action-hover);
            transform: scale(1.05) !important;
        }

        h1:active,
        h1:focus-visible {
            color: var(--color-action-default);
            transform: scale(1) !important;
        }

        button {
            align-items: center;
            background-color: var(--color-action-default);
            border: 3px solid var(--color-dark);
            border-radius: var(--circle);
            box-shadow: var(--shadow);
            color: var(--color-dark);
            cursor: pointer;
            display: inline-flex;
            font: inherit;
            padding: var(--spacing-s);
            margin: var(--spacing-m);
            touch-action: manipulation;
            transition-property: background-color, outline;
            transition-duration: 180ms;
            transition-timing-function: ease-in-out;
        }

        button:hover {
            background-color: var(--color-action-hover);
        }

        :where(button:active, button:focus-visible) {
            outline: 5px solid hsla(var(--hue) 80% 25% / .5);
            outline-offset: -1px;
        }

        button:active {
            background-color: var(--color-action-active);
        }

        main {
            position: relative;
            height: var(--diameter);
            width: var(--diameter);
        }

        fieldset {
            --cell-size: fit-content;
            --offset: calc(360deg / var(--i-count));
            position: absolute;
            top: 0;
            left: 0;
            display: grid;
            grid: var(--cell-size) / var(--cell-size);
            place-content: center;
            height: 100%;
            width: 100%;
            border: none;
            padding: 0 !important;
        }

        fieldset>* {
            grid-area: 1/1;
        }

        input {
            --angle: calc((var(--i) * var(--offset)) - 90deg);
            appearance: none;
            border-radius: var(--circle);
            cursor: pointer;
            height: 2.75rem;
            width: 2.75rem;
            touch-action: manipulation;
            /* translate: calc(cos(var(--angle)) * var(--diameter)) calc(sin(var(--angle)) * var(--diameter)); */
            transform: translate3d(calc(cos(var(--angle)) * var(--diameter)), calc(sin(var(--angle)) * var(--diameter)), 0);
            will-change: transform;
        }

        :where(input:checked, input:focus-visible) {
            outline: 3px solid white;
            z-index: var(--top);
            transition: none;
        }

        /* Fade hover outlines during/after drag, but keep checked outline */
        fieldset.dragging input:hover {
            outline-color: transparent;
            transition: outline 80ms ease-in-out;
        }

        input:focus {
            z-index: var(--top);
        }

        .mode-hue input {
            background: hsl(calc(var(--i) * 1deg), 100%, 50%);
        }

        .mode-saturation input {
            background: hsl(var(--hue), calc(var(--i) * 1%), 50%);
        }

        .mode-lightness input {
            background: hsl(var(--hue), calc(var(--saturation) * 1%), calc(var(--i) * 1%));
        }

        .no-hover * {
            pointer-events: none !important;
        }

        .value-display {
            position: absolute;
            top: 50%;
            left: 50%;
            height: fit-content;
            width: fit-content;
            overflow: visible;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: var(--top);
        }

        text {
            fill: var(--color-light);
            font-size: var(--typography-size-xl);
            font-weight: bold;
            dominant-baseline: central;
            text-anchor: middle;
            paint-order: stroke;
            stroke: var(--color-dark);
            stroke-width: 3px;
            stroke-linejoin: round;
        }

        a {
            color: currentColor;
            text-decoration-color: currentColor;
            text-underline-offset: .25ex;
            text-decoration-thickness: .05ex;
        }

        a:hover {
            text-decoration-thickness: .10ex;
        }

        :where(abbr[title]) {
            cursor: help;
            text-decoration-line: underline;
            text-decoration-style: dotted;
        }

        footer small {
            background-color: var(--color-dark);
            border-radius: 0 var(--corner) 0 0;
            color: var(--color-light);
            display: inline-block;
            font-size: var(--typography-size-s);
            padding-block: var(--spacing-xs);
            padding-inline: var(--spacing-l);
        }

        footer small:last-of-type {
            border-radius: var(--corner) 0 0 0;
        }

        .center {
            box-sizing: content-box;
            margin-inline: auto;
            max-inline-size: none;
            text-align: center;
        }

        .cover {
            display: flex;
            flex-direction: column;
            min-block-size: 100vh;
        }

        .cover>* {
            margin-block: 0;
        }

        .cover> :first-child:not(main) {
            margin-block-start: 0;
        }

        .cover> :last-child:not(main) {
            margin-block-end: 0;
        }

        .cover>main {
            margin-block: auto;
        }

        .with-icon {
            display: inline-flex;
            align-items: center;
        }

        .icon {
            height: 2.6cap;
            width: 2.6cap;
            transition: opacity 300ms ease-in-out 240ms;
        }

        .with-icon .icon {
            margin-inline-end: 0;
        }

        .icon-check {
            opacity: 0;
            position: absolute;
        }

        .copy-success .icon-copy {
            opacity: 0;
        }

        .copy-success .icon-check {
            opacity: 1;
        }

        .stack-x {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-l);
            align-items: flex-start;
            justify-content: space-between;
        }

        .visually-hidden:not(:focus):not(:active):not(:focus-within) {
            clip-path: inset(50%);
            block-size: 1px;
            inline-size: 1px;
            overflow: hidden;
            position: absolute !important;
            white-space: nowrap;
        }
    </style>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="author" content="Timothy Martens">
    <meta name="description" content="Hueyâ€”HSL Color Toy">
</head>

<body class="center cover">

    <header class="stack-x">
        <button class="with-icon" id="random-btn" title="Random Color">
            <svg class="icon" aria-hidden="true">
                <use href="#icon-random"></use>
            </svg>
            <span class="visually-hidden">Randomize</span>
        </button>
        <h1 class="mode-title" title="Switch Modes">H</h1>
        <button class="with-icon" id="copy-btn" title="Copy Color">
            <svg class="icon icon-copy" aria-hidden="true">
                <use href="#icon-copy"></use>
            </svg>
            <svg class="icon icon-check" aria-hidden="true">
                <use href="#icon-check"></use>
            </svg>
            <span class="visually-hidden">Copy/Confirm Copy</span>
        </button>
    </header>

    <main class="center">
        <fieldset style="--i-count:360" role="radiogroup" aria-label="Color component selector" aria-labelledby="mode-title" aria-describedby="color-instructions">
        </fieldset>
        <svg class="value-display" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" aria-hidden="true">
            <text x="50" y="50" class="component-value">360</text>
        </svg>
    </main>

    <div id="color-instructions" class="visually-hidden">
        <p>Use arrow keys to adjust the selected color component. Press Tab to switch between Hue, Saturation, and Lightness modes. Press Home or End to jump to minimum or maximum values. Hold down arrow keys for faster navigation.</p>
    </div>

    <footer class="stack-x">
        <small>HUEy&mdash;<abbr title="Hue, Saturation, Lightness">HSL</abbr> color toy</small>
        <small>&copy; &apos;25 <a href="https://timpish.com" aria-label="Visit Timothy Martens' website">Timothy Martens</a></small>
    </footer>

    <svg class="visually-hidden" display="none" aria-hidden="true" height="0" width="0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <symbol id="icon-random" title="Random Color Icon" viewBox="0 0 256 256">
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="M32 72h23.06a64 64 0 0 1 52.08 26.8l41.72 58.4a64 64 0 0 0 52.08 26.8H232M208 48l24 24-24 24" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="m208 160 24 24-24 24M152.77 93.86A64 64 0 0 1 200.94 72H232M32 184h23.06a64 64 0 0 0 48.17-21.86" />
            </symbol>
            <symbol id="icon-copy" title="Copy Color Icon" viewBox="0 0 256 256">
                <path fill="none" d="M0 0h256v256H0z" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="M40 76h140v140H40z" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="M76 40h140v140" />
            </symbol>
            <symbol id="icon-check" title="Confirm Copy Color Icon" viewBox="0 0 256 256">
                <path fill="none" d="M0 0h256v256H0z" />
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="24" d="m40 144 56 56L224 72" />
            </symbol>
        </defs>
    </svg>

    <script>/**
* HSL Color Toy - Refactored for better modularity and performance
*/

        // Constants
        const MODES = Object.freeze(['hue', 'saturation', 'lightness']);
        const MODE_RANGES = Object.freeze({
            hue: { min: 1, max: 360 },
            saturation: { min: 0, max: 100 },
            lightness: { min: 1, max: 100 }
        });
        const MODE_LABELS = Object.freeze({
            hue: 'H',
            saturation: 'S',
            lightness: 'L'
        });
        const REGENERATION_DELAY = 150;

        // Utility functions
        const utils = {
            debounce(fn, delay) {
                let timer;
                return (...args) => {
                    clearTimeout(timer);
                    timer = setTimeout(() => fn.apply(this, args), delay);
                };
            },

            hslToRgb(h, s, l) {
                s /= 100;
                l /= 100;
                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;

                let r = 0, g = 0, b = 0;
                const sector = Math.floor(h / 60);

                switch (sector) {
                    case 0: [r, g, b] = [c, x, 0]; break;
                    case 1: [r, g, b] = [x, c, 0]; break;
                    case 2: [r, g, b] = [0, c, x]; break;
                    case 3: [r, g, b] = [0, x, c]; break;
                    case 4: [r, g, b] = [x, 0, c]; break;
                    case 5: [r, g, b] = [c, 0, x]; break;
                }

                return {
                    r: Math.round((r + m) * 255),
                    g: Math.round((g + m) * 255),
                    b: Math.round((b + m) * 255)
                };
            },

            getRelativeLuminance(r, g, b) {
                const normalize = (val) => {
                    val /= 255;
                    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
                };

                return 0.2126 * normalize(r) + 0.7152 * normalize(g) + 0.0722 * normalize(b);
            },

            getContrastRatio(rgb1, rgb2) {
                const l1 = this.getRelativeLuminance(rgb1.r, rgb1.g, rgb1.b);
                const l2 = this.getRelativeLuminance(rgb2.r, rgb2.g, rgb2.b);
                const [lighter, darker] = [Math.max(l1, l2), Math.min(l1, l2)];
                return (lighter + 0.05) / (darker + 0.05);
            },

            angleToValue(angle, mode) {
                const { min, max } = MODE_RANGES[mode];
                if (mode === 'hue') {
                    return Math.max(1, Math.round(angle)) || 360;
                }
                const normalizedAngle = angle / 360;
                return Math.max(min, Math.min(max, Math.round(min + (normalizedAngle * (max - min)))));
            },

            clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }
        };

        // State management
        class ColorState {
            constructor() {
                this.state = { hue: 360, saturation: 100, lightness: 50, mode: 'hue' };
                this.observers = [];
            }

            subscribe(callback) {
                this.observers.push(callback);
                return () => this.observers = this.observers.filter(obs => obs !== callback);
            }

            setState(updates) {
                const prevState = { ...this.state };
                this.state = { ...this.state, ...updates };
                this.observers.forEach(obs => obs(this.state, prevState));
            }

            get(key) {
                return key ? this.state[key] : this.state;
            }
        }

        // Event handling
        class EventManager {
            constructor(colorToy) {
                this.toy = colorToy;
                this.keyHoldStart = 0;
                this.isDragging = false;
                this.boundMethods = this.bindMethods();
            }

            bindMethods() {
                return {
                    globalKeydown: this.handleGlobalKeydown.bind(this),
                    fieldsetKeydown: this.handleFieldsetKeydown.bind(this),
                    fieldsetKeyup: this.handleFieldsetKeyup.bind(this),
                    dragStart: this.handleDragStart.bind(this),
                    dragMove: this.handleDragMove.bind(this),
                    dragEnd: this.handleDragEnd.bind(this)
                };
            }

            addListeners() {
                const { elements } = this.toy;

                // Button events
                elements.copyBtn.addEventListener('click', () => this.toy.copyHSLToClipboard());
                elements.randomBtn.addEventListener('click', () => this.toy.generateRandomColor());

                // Mode switching
                elements.appTitle.addEventListener('click', () => this.toy.cycleModes());
                elements.appTitle.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.toy.cycleModes();
                });

                // Keyboard navigation
                document.addEventListener('keydown', this.boundMethods.globalKeydown);
                elements.fieldset.addEventListener('keydown', this.boundMethods.fieldsetKeydown);
                elements.fieldset.addEventListener('keyup', this.boundMethods.fieldsetKeyup);
                elements.fieldset.addEventListener('blur', () => this.resetKeyHold());

                // Drag functionality
                this.addDragListeners();
            }

            addDragListeners() {
                const { main } = this.toy.elements;

                // Mouse events
                main.addEventListener('mousedown', this.boundMethods.dragStart);
                document.addEventListener('mousemove', this.boundMethods.dragMove);
                document.addEventListener('mouseup', this.boundMethods.dragEnd);

                // Touch events
                main.addEventListener('touchstart', this.boundMethods.dragStart, { passive: false });
                document.addEventListener('touchmove', this.boundMethods.dragMove, { passive: false });
                document.addEventListener('touchend', this.boundMethods.dragEnd);

                main.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            handleGlobalKeydown(e) {
                if (e.key === 'Tab' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                    e.preventDefault();
                    this.toy.cycleModes();
                }
            }

            handleFieldsetKeydown(e) {
                const isArrowKey = ['ArrowRight', 'ArrowUp', 'ArrowLeft', 'ArrowDown'].includes(e.key);
                const isHomeEnd = ['Home', 'End'].includes(e.key);

                if (!isArrowKey && !isHomeEnd) return;
                e.preventDefault();

                const mode = this.toy.state.get('mode');
                const { min, max } = MODE_RANGES[mode];

                if (e.key === 'Home') return this.toy.setValueAndFocus(min);
                if (e.key === 'End') return this.toy.setValueAndFocus(max);

                this.handleArrowNavigation(e);
            }

            handleArrowNavigation(e) {
                if (this.keyHoldStart === 0) this.keyHoldStart = Date.now();

                const holdDuration = Date.now() - this.keyHoldStart;
                const useAcceleration = holdDuration > 1500;
                const isForward = ['ArrowRight', 'ArrowUp'].includes(e.key);

                this.toy.navigateValue(isForward ? 'forward' : 'backward', useAcceleration);
            }

            handleFieldsetKeyup(e) {
                if (['ArrowRight', 'ArrowUp', 'ArrowLeft', 'ArrowDown'].includes(e.key)) {
                    this.resetKeyHold();
                }
            }

            handleDragStart(e) {
                e.preventDefault();
                this.isDragging = true;

                const { main, fieldset } = this.toy.elements;
                main.style.cursor = 'grabbing';
                document.body.style.userSelect = 'none';
                fieldset.classList.add('dragging');

                this.handleDragMove(e);
            }

            handleDragMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const mainRect = this.toy.elements.main.getBoundingClientRect();
                const centerX = mainRect.left + mainRect.width / 2;
                const centerY = mainRect.top + mainRect.height / 2;

                const deltaX = clientX - centerX;
                const deltaY = clientY - centerY;
                const angle = ((Math.atan2(deltaY, deltaX) * (180 / Math.PI) + 90 + 360) % 360);

                const mode = this.toy.state.get('mode');
                const newValue = utils.angleToValue(angle, mode);

                if (newValue !== this.toy.state.get(mode)) {
                    this.toy.state.setState({ [mode]: newValue });
                    this.toy.updateCheckedInput(newValue);
                }
            }

            handleDragEnd() {
                if (!this.isDragging) return;

                this.isDragging = false;
                const { main, fieldset } = this.toy.elements;

                main.style.cursor = '';
                document.body.style.userSelect = '';

                this.toy.focusCurrentValue();
                setTimeout(() => fieldset.classList.remove('dragging'), 300);
            }

            resetKeyHold() {
                this.keyHoldStart = 0;
            }
        }

        // DOM management
        class DOMManager {
            constructor(colorToy) {
                this.toy = colorToy;
                this.elements = this.cacheElements();
                this.debouncedRegeneration = utils.debounce(() => this.regenerateInputs(), REGENERATION_DELAY);
            }

            cacheElements() {
                return {
                    root: document.documentElement,
                    fieldset: document.querySelector('fieldset'),
                    appTitle: document.querySelector('.mode-title'),
                    componentValue: document.querySelector('.component-value'),
                    copyBtn: document.getElementById('copy-btn'),
                    randomBtn: document.getElementById('random-btn'),
                    main: document.querySelector('main')
                };
            }

            updateModeDisplay(mode) {
                this.elements.appTitle.textContent = MODE_LABELS[mode];
                this.elements.fieldset.className = `center mode-${mode}`;
                this.elements.fieldset.setAttribute('aria-label', `${mode} selector`);

                // Animation feedback
                const { appTitle } = this.elements;
                appTitle.style.transform = 'scale(1.1)';
                appTitle.style.transition = 'all 120ms ease-in-out';
                setTimeout(() => appTitle.style.transform = 'scale(1)', 120);
            }

            regenerateInputs() {
                const mode = this.toy.state.get('mode');
                const currentValue = this.toy.state.get(mode);
                const hadFocus = this.elements.fieldset.contains(document.activeElement);

                this.elements.fieldset.innerHTML = '';
                this.generateInputs(mode);
                this.addInputListeners();

                const targetInput = this.elements.fieldset.querySelector(`input[value="${currentValue}"]`);
                if (targetInput) {
                    targetInput.checked = true;
                    if (hadFocus) {
                        requestAnimationFrame(() => targetInput.focus());
                    }
                }
            }

            generateInputs(mode) {
                const { min, max } = MODE_RANGES[mode];
                const inputCount = mode === 'hue' ? 360 : 100;

                this.elements.fieldset.style.setProperty('--i-count', inputCount.toString());

                const fragment = document.createDocumentFragment();
                for (let i = min; i <= max; i++) {
                    fragment.appendChild(this.createRadioInput(i, mode));
                }
                this.elements.fieldset.appendChild(fragment);
            }

            createRadioInput(value, mode) {
                const input = document.createElement('input');
                const labels = {
                    hue: `${value} degrees`,
                    saturation: `${value} percent saturation`,
                    lightness: `${value} percent lightness`
                };

                Object.assign(input, {
                    type: 'radio',
                    name: mode.charAt(0),
                    value: value
                });

                input.style.setProperty('--i', value);
                input.setAttribute('aria-label', labels[mode]);

                return input;
            }

            addInputListeners() {
                this.elements.fieldset.querySelectorAll('input[type="radio"]').forEach(input => {
                    input.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            const mode = this.toy.state.get('mode');
                            this.toy.state.setState({ [mode]: parseInt(e.target.value) });
                            e.target.focus();
                        }
                    });
                });
            }

            updateDisplay({ hue, saturation, lightness }) {
                const { root, componentValue } = this.elements;
                const mode = this.toy.state.get('mode');

                // Update CSS properties
                root.style.setProperty('--hue', hue);
                root.style.setProperty('--saturation', saturation);
                root.style.setProperty('--lightness', lightness);
                root.style.setProperty('--color-canvas', `hsl(${hue}, ${saturation}%, ${lightness}%)`);

                // Update dynamic colors
                const dynamicColors = this.calculateDynamicColors(hue, saturation, lightness);
                root.style.setProperty('--color-dark', dynamicColors.background);
                root.style.setProperty('--color-light', dynamicColors.foreground);

                // Update display text
                componentValue.textContent = this.toy.state.get(mode);
            }

            calculateDynamicColors(hue, saturation, lightness) {
                const mainRgb = utils.hslToRgb(hue, saturation, lightness);

                let headerLightness = 25;
                if (lightness > 80) headerLightness = 12;
                else if (lightness > 60) headerLightness = 18;
                else if (lightness > 40) headerLightness = 22;

                const headerSaturation = utils.clamp(saturation * 0.9, 40, 85);
                let headerBgRgb = utils.hslToRgb(hue, headerSaturation, headerLightness);

                if (utils.getContrastRatio(mainRgb, headerBgRgb) < 4.5) {
                    headerLightness = Math.max(8, headerLightness - 5);
                    headerBgRgb = utils.hslToRgb(hue, headerSaturation, headerLightness);
                }

                const fgLightness = 92;
                const fgSaturation = Math.min(40, headerSaturation * 0.6);

                return {
                    background: `hsl(${hue}, ${headerSaturation}%, ${headerLightness}%)`,
                    foreground: `hsl(${hue}, ${fgSaturation}%, ${fgLightness}%)`
                };
            }
        }

        // Main class
        class HSLColorToy {
            constructor() {
                this.state = new ColorState();
                this.dom = new DOMManager(this);
                this.events = new EventManager(this);
                this.elements = this.dom.elements;

                this.init();
            }

            init() {
                this.state.subscribe((newState) => this.dom.updateDisplay(newState));
                this.dom.generateInputs(this.state.get('mode'));
                this.dom.addInputListeners();
                this.events.addListeners();
                this.setInitialState();
            }

            setInitialState() {
                const mode = this.state.get('mode');
                const currentValue = this.state.get(mode);

                this.dom.updateModeDisplay(mode);

                const initialRadio = this.elements.fieldset.querySelector(`input[value="${currentValue}"]`);
                if (initialRadio) {
                    initialRadio.checked = true;
                    initialRadio.focus();
                }

                this.dom.updateDisplay(this.state.get());
            }

            cycleModes() {
                const currentIndex = MODES.indexOf(this.state.get('mode'));
                const nextMode = MODES[(currentIndex + 1) % MODES.length];
                this.switchMode(nextMode);
                this.focusCurrentValue();
            }

            switchMode(newMode) {
                this.state.setState({ mode: newMode });
                this.dom.updateModeDisplay(newMode);
                this.dom.debouncedRegeneration();
            }

            setValueAndFocus(value) {
                const radio = this.elements.fieldset.querySelector(`input[value="${value}"]`);
                if (radio) {
                    radio.checked = true;
                    radio.focus();
                    const mode = this.state.get('mode');
                    this.state.setState({ [mode]: value });
                }
            }

            updateCheckedInput(value) {
                const targetInput = this.elements.fieldset.querySelector(`input[value="${value}"]`);
                if (targetInput) targetInput.checked = true;
            }

            focusCurrentValue() {
                setTimeout(() => {
                    const currentValue = this.state.get(this.state.get('mode'));
                    const targetInput = this.elements.fieldset.querySelector(`input[value="${currentValue}"]`);
                    if (targetInput) {
                        targetInput.checked = true;
                        targetInput.focus();
                    }
                }, 10);
            }

            navigateValue(direction, accelerated = false) {
                const checked = this.elements.fieldset.querySelector('input:checked');
                if (!checked) return;

                const currentValue = parseInt(checked.value);
                const mode = this.state.get('mode');
                const increment = accelerated ? 9 : 1;
                const { min, max } = MODE_RANGES[mode];

                let newValue;
                if (direction === 'forward') {
                    newValue = currentValue + increment;
                    if (newValue > max) {
                        newValue = mode === 'hue' ? newValue - 360 : min;
                    }
                } else {
                    newValue = currentValue - increment;
                    if (newValue < min) {
                        newValue = mode === 'hue' ? 360 + newValue : max;
                    }
                }

                this.setValueAndFocus(newValue);
            }

            generateRandomColor() {
                this.state.setState({
                    hue: Math.floor(Math.random() * 360) + 1,
                    saturation: Math.floor(Math.random() * 21) + 80,
                    lightness: Math.floor(Math.random() * 21) + 40
                });

                this.focusCurrentValue();
            }

            async copyHSLToClipboard() {
                const { hue, saturation, lightness } = this.state.get();
                const hslString = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

                try {
                    await navigator.clipboard.writeText(hslString);
                    this.showCopySuccess();
                } catch (err) {
                    this.fallbackCopy(hslString);
                    this.showCopySuccess();
                }
            }

            fallbackCopy(text) {
                const textArea = Object.assign(document.createElement('textarea'), { value: text });
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
            }

            showCopySuccess() {
                this.elements.copyBtn.classList.add('copy-success');
                setTimeout(() => this.elements.copyBtn.classList.remove('copy-success'), 1000);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            try {
                new HSLColorToy();
            } catch (error) {
                console.error('Error initializing HSL Color Toy:', error);
            }
        });</script>

</body>

</html>
